<!DOCTYPE html><html data-n-head="" data-n-head-ssr><meta data-n-head="true" charset="utf-8"><meta data-n-head="true" content="width=device-width,initial-scale=1" name="viewport"><meta data-n-head="true" content="Nuxt.js project" name="description" data-hid="description"><title data-n-head="true">360威胁情报中心</title><link href="/fav.ico" rel="icon" data-n-head="true" type="image/x-icon"><link href="/_nuxt/manifest.38f62477280dcc27df9e.js" rel="preload" as="script"><link href="/_nuxt/vendor.bundle.45eca4dc7fa9e1bc4361.js" rel="preload" as="script"><link href="/_nuxt/nuxt.bundle.8e9d53f64bed77ebfe81.js" rel="preload" as="script"><link href="/_nuxt/0.nuxt.bundle.2f45ca512d92831b456d.js" rel="prefetch"><link href="/_nuxt/1.nuxt.bundle.ddf9ea85dc483e3df228.js" rel="prefetch"><link href="/_nuxt/2.nuxt.bundle.ae682d6568221e03d161.js" rel="prefetch"><link href="/_nuxt/3.nuxt.bundle.55fb549cb8ff45291a32.js" rel="prefetch"><link href="/_nuxt/4.nuxt.bundle.34c699b301359d6a3c4d.js" rel="prefetch"><link href="/_nuxt/5.nuxt.bundle.1375829ca49ba88d696d.js" rel="prefetch"><style data-vue-ssr-id="1cbf7f39:0 198c0e1e:0 034fd8e0:0 ba3a09e0:0 c2ba7178:0 01cb4693:0 69b5e360:0">.progress[data-v-862bdd9c]{position:fixed;top:0;left:0;right:0;height:2px;width:0;-webkit-transition:width .2s,opacity .4s;-o-transition:width .2s,opacity .4s;transition:width .2s,opacity .4s;opacity:1;background-color:#efc14e;z-index:999999}.hljs ::-webkit-scrollbar{width:8px;height:10px;border-radius:2px;background-color:#839496}.hljs ::-webkit-scrollbar-track{background-color:#bebebe}.hljs ::-webkit-scrollbar-thumb,.hljs ::-webkit-scrollbar-track{border-radius:2px;-webkit-box-shadow:inset 0 0 6px rgba(0,0,0,.3)}.hljs ::-webkit-scrollbar-thumb{background-color:#789}html{font-family:Source Sans Pro,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica Neue,Arial,sans-serif;font-size:16px;word-spacing:1px;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;-webkit-box-sizing:border-box;box-sizing:border-box}body{background-color:rgba(66,66,66,.05)}*,:after,:before{-webkit-box-sizing:border-box;box-sizing:border-box;margin:0;text-decoration:none}li{list-style-type:none}a:active,a:hover,a:link,a:visited{color:#0b1802}.main-body h1,.main-body h2,.main-body h3,.main-body h4,.main-body h5,.main-body h6{margin-top:0;margin-bottom:.5rem}.main-body p{margin-top:0;margin-bottom:1rem;font-size:15px;text-indent:25px;word-wrap:break-word}.main-body img{vertical-align:middle;border-style:none;margin:auto 20px auto auto;padding:3px;border-radius:3px;background-color:#e6e6d5;-webkit-box-shadow:0 1px 2px rgba(0,0,0,.15);box-shadow:0 1px 2px rgba(0,0,0,.15);border:1px solid #b9baa6}.main-body .text-center{text-align:center!important}.main-body table{border-collapse:collapse!important;width:100%;max-width:100%;margin:1em 0;background-color:transparent}.main-body table tbody+tbody{border-top:2px solid #e9ecef}.main-body table td,.main-body table th{padding:.5rem;font-size:.95em;border-collapse:collapse}.main-body table tr{border:1px solid #dfe8fe}.main-body table tr:nth-child(odd){background-color:#ecf1fe}.main-body table tr:nth-child(2n){background-color:#fdfdfd}.main-body table td{white-space:normal;word-break:break-all}.main-body code,.main-body kbd,.main-body pre,.main-body samp{font-family:Menlo,Monaco,Consolas,Liberation Mono,Courier New,monospace}.nav-bar[data-v-42857612]{height:60px;border-bottom:1px solid #d5d5d5}.nav-bar .ico-favicon[data-v-42857612]{height:28px;margin-top:16px;margin-left:108px;cursor:pointer}.nav-bar .ico-home[data-v-42857612]{width:32px;height:32px;display:inline-block;margin:16px 32px;float:right;cursor:pointer;background:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAACU0lEQVRYR+2XzZHaQBCFX48cAM4AStxNBmYzACSfDREYIjAbAcoA9mwkcARmM1jfocAZbADWPNfIDAtaCUmUXdhV6Cjm5+vX3Y+W4MqPXPl+XAzQWWxrSuvPJgCt1P2y23i+JJiLADqLbcuJ9RSCVnIp8RQ7arDsNp6qQlQG6IXrPiATIYTCoblQKAEFBDiKvOasCkRpgL3kEwH6BL5rpfo2YqOI0nomwDsCM63UqGxKSgGcSE4+xI4zTF9gAJ04DiDysUpKCgHSkhdJbNZXSUkuQJ7k+0inFHmMPDfIync6JZHnDvLqIhOgs9jWnVgvkio/kvxwMDkO/ebyXLFlpKS77DZ26T2vALz5ukORqQA1ggMreS/cmIrva6U6WQflwZh9AkwIPAs5SIOfAHjzTQDBJ3tY6LliJQfkR+i7SdtVfXrhZixAYloEgshzR/aMA0AvXK8E8h7kV4rUTUsZALMZ4K6o+M5BWQDTvuZckKvQb94lHmI3mugp2JnCsjAWQGm1mn9orKpGbtdbANHqTivdEqJu1cwswr8JkA7kBlCogOmCsr5+phWTLjA18P+lwP+ybf98g501nxdfQC0r4thxzD/hyVxw3AWVFUhfYp0ttyXJh9Bv9o9//9MAufn0wg0JPkZes30DuCnwTyoQK/U2bWqZTniYC8hueoA411L5XbBeCaUV+u4r78gEMOZDpb/Zjw6Ah6+e/axQN5Pv8ftkrUh7P/kcjIgird/TFe4jzx0XjmR2QQIh8ZCS7XhlZwMhDPwsb4YsHMvLXnTpuqsD/AKIkSQ/Gqk/IAAAAABJRU5ErkJggg==) no-repeat}.nav-bar .ico-home[data-v-42857612]:hover{background:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAACRElEQVRYR+2XT5LSQBTGvy9B13gDbmBuIJSJ65kTGKqEciecQOYEsJxKrII5gboVLJgbzNwAb8Aah7ypjmnMNPlLaaFV9DLV3e/3vvcnr4kTL57YPo4G8JfSfP6Aj8qBbQNXsw43xzhzFEDvmzggpiQcZVQEdxB0wze8qwtRG6D3XXwIxhRQLAyUQUaYCCEghuFrzupAVAZQkj/bYUzAB3AvEXztsVKEFpThlwLMftoYVg1JJQBD8putjYFpIM6JHSYA3tYJSSmAKXmZxGp/nZDkAuRJnng6heA28Kg8PlhmSEKX3by8yAR4v5TW7gGfkyzfS566eBS4/FKUbGZI7AYurztcm2cOAPoLuRBgSqApRFdL3p/LAIRv2bjIuigPJjk3FmBDoGuCPwHoLWRC4IO+LHBJLbkAP0KXcdnVXf25jMBfTQuCSeBxqO/YA/TmsiLxSgRfSbRUSSkAdVgsrMuSrwgqBXCflOoqdNmJe4g+GHsvWKvE0jAaIAJWnzyu6nqu92uASNCxAEeIllYzMwn/JoDpyBmgVAFVBVX7ekEpxlWgcuD/C8G7ubQbDax180n1hWamxxGG5lyQroLaCphGdGcrKMmbwKX6Ze/XnwbIjWd/ISKC29Bj+wxwVuCfVGBr44XZ1LI74e+54NIcIIpKKq8K4p8b4AQeD3pHJoBqPhaxjOcH9egg9q8eIp4VWub35N/eVpMPgPQDxVHTFQRXgcdR6UimNygIIn54ZHe86sPBhsQsb4YsHcur2zlu58kBHgGcWwk/vbbC3wAAAABJRU5ErkJggg==) no-repeat}.disPic .pic[data-v-42857612]{background-color:#faa732;height:480px;width:100%}.article-page[data-v-8db87e62]{margin:0 auto;max-width:1108px;background-size:cover}.article-page .page-header[data-v-8db87e62]{border-bottom:1px solid #efefef}.article-page .page-header .ava img[data-v-8db87e62]{border-radius:50%;height:56px;width:56px;float:left;margin:12px}.article-page .page-header .title[data-v-8db87e62]{font-size:48px;color:#0b1802;font-family:"Verdana, \5FAE\8F6F\96C5\9ED1, \5B8B\4F53, Geneva, 'sans-serif'"}.article-page .page-header .author[data-v-8db87e62]{display:inline-block;color:#979996;font-size:16px;font-family:"Verdana, \5FAE\8F6F\96C5\9ED1, \5B8B\4F53, Geneva, 'sans-serif'";margin:12px 7px 12px 0;line-height:16px}.article-page .page-header .author .ico-time img[data-v-8db87e62]{width:16px;height:16px}.article-page .main-body[data-v-8db87e62]{padding:0 108px;margin:28px auto 168px;background:url(/_nuxt/img/post-entry-bg.98216ca.png) no-repeat -10px 9px}.article-page .back-top[data-v-8db87e62]{width:48px;height:48px;position:fixed;bottom:30px;right:20px;background:url(/_nuxt/img/top.1d1a857.png) no-repeat}.article-page .back-top[data-v-8db87e62]:hover{cursor:pointer;background:url(/_nuxt/img/top-light.0cd636b.png) no-repeat}.title-home[data-v-552f8598]{font-family:sans-serif;line-height:32px;font-size:24px;color:#0b1802;cursor:pointer;max-height:32px;overflow:hidden;-o-text-overflow:ellipsis;text-overflow:ellipsis}.title-home[data-v-552f8598]:hover{text-shadow:2px 3px 1px #d0d0d0}.title-detail[data-v-552f8598]{font-size:48px;color:#0b1802;font-family:Arial Rounded MT Bold;margin-top:48px;line-height:64px}@media screen and (min-width:550px) and (max-width:950px){.title-home div[data-v-552f8598]{overflow:hidden;-o-text-overflow:ellipsis;text-overflow:ellipsis;white-space:nowrap}}@media screen and (max-width:550px){.title-home div[data-v-552f8598]{overflow:hidden;-o-text-overflow:ellipsis;text-overflow:ellipsis;white-space:nowrap}}.tags[data-v-53a17526]{height:42px;padding-top:10px}.tag[data-v-53a17526]{background-color:#6aacd8;display:inline-block;height:22px;font-size:13px;color:#fefefe;font-family:sans-serif;padding:2px 6px;margin-right:8px;border-radius:2px}</style><body data-n-head=""><div data-server-rendered="true" id="__nuxt"><div class="progress" data-v-862bdd9c style="width:0%;height:2px;background-color:#3b8070;opacity:0"></div><div><section><div data-v-42857612><div class="nav-bar" data-v-42857612><a href="/" data-v-42857612><img src="/_nuxt/img/blog-icon.f80549d.png" class="ico-favicon" data-v-42857612></a><div class="ico-home" data-v-42857612></div></div><!----></div><div class="article-page" data-v-8db87e62><div class="page-header" data-v-8db87e62><div class="title-detail" data-v-552f8598 data-v-8db87e62>Petya变种勒索蠕虫启动代码分析</div><div class="ava" data-v-8db87e62><img data-v-8db87e62></div><div class="tags" data-v-53a17526 data-v-8db87e62><p class="tag" data-v-53a17526>MBR<p class="tag" data-v-53a17526>PETYA</div><div class="author lh32" data-v-8db87e62>马茂刚 on</div></div><div class="main-body" data-v-8db87e62><h1 class="line" data-line="0">背景</h1><p class="line" data-line="2">继5月的WannaCry勒索蠕虫事件以后，2017年6月又出现了Petya变种勒索蠕虫，除了利用永恒之蓝漏洞和加密勒索以后，Petya变种与WannaCry有比较大的差别。WannaCry会加密机器上的文件，导致数据损毁，而Petya更为激进，它会加密系统的MBR直接导致机器无法启动，本文对其执行的MBR及文件系统的加密机制做详细的分析。<h1 class="line" data-line="4">恶意代码分析</h1><p class="line" data-line="6">由于执行恶意操作的指令并不是以文件形式存在，我们使用WinHex工具提取受攻击机器的磁盘前23个扇区的数据进行分析，对应代码数据的Hash为 841e12729f200a5620859f2958e2d484。<h2 class="line" data-line="8">相关数据结构</h2><p class="line" data-line="10">计算机启动时执行完BIOS的启动代码，检查各硬件设备正常后，JMP到MBR的引导代码进行执行；然后由MBR引导至活动分区的DBR，再由DBR引导操作系统。如：DBR调用NTLDR，再由NTLDR调用系统内核。<p class="line" data-line="12">Petya病毒修改了系统的MBR，病毒在Bios加载后获得执行机会，病毒将加载存储在0x1扇区后的大小为0x20大小的病毒代码加载执行，这些代码会还原出真实的MBR，通过对还原出来的MBR解析，得到系统的DBR，通过DBR解析到系统的MFT结构，遍历所有的MFT，根据MFT找到文件内容所在的扇区后，读取该扇区加密内容后再写回到扇区中，从而实现对文件的加密。要完整的了解整个的加密过程，首先就是熟悉系统的MBR、DBR、MFT等结构的含义与功能。<h3 class="line" data-line="14">MBR</h3><p class="line" data-line="16">Petya病毒修改了系统的MBR，病毒在Bios加载后获得执行机会，病毒将加载存储在0x1扇区后的大小为0x20大小的病毒代码加载执行，这些代码会还原出真实的MBR。在加密文件的过程中，Petya病毒会使用到MBR中<p class="line" data-line="18">MBR扇区由以下四部分组成：<ul><li>引导代码：引导代码占MBR分区的前440字节，负责整个系统启动。如果引导代码被破坏，系统将无法启动。<li>Windows磁盘签名：占引导代码后面的4字节，是Windows初始化磁盘写入的磁盘标签，如果此标签被破坏，则系统会提示“初始化磁盘”。<li>MBR分区表：占Windows磁盘标签后面的64个字节，是整个硬盘的分区表。<li>MBR结束标志：占MBR扇区最后2个字节，一直为“55 AA”。</ul><p class="line" data-line="25">MBR结构如下：<pre class="hljs"><code class="hljs">;====================================================================
    主引导记录(MBR)结构
;====================================================================
 typedef struct _MASTER_BOOT_RECORD
 {
  UCHAR    BootCode[446];
  PARTITION_ENTRY  Partition[4];
  USHORT    Signature;
 }MASTER_BOOT_RECORD,*PMASTER_BOOT_RECORD;
 
;====================================================================
;====================================================================
     分区表项结构(16字节)
;====================================================================
 
 typedef struct _PARTITION_ENTRY
 {
  UCHAR BootIndicator;  // 能否启动标志
  UCHAR StartHead;   // 该分区起始磁头号
  UCHAR StartSector;  // 起始柱面号高2位：6位起始扇区号
  UCHAR StartCylinder;  // 起始柱面号低8位
  UCHAR PartitionType;  // 分区类型
  UCHAR EndHead;   // 该分区终止磁头号
  UCHAR EndSector;   // 终止柱面号高2位：6位终止扇区号
  UCHAR EndCylinder;  // 终止柱面号低8位
  ULONG StartLBA;   // 起始扇区号
  ULONG TotalSector;  // 分区尺寸（总扇区数）
 }PARTITION_ENTRY,*PPARTITION_ENTRY;
</code></pre><p class="line" data-line="58">对于其中的PartitionType 字段，Windows下可识别的分区类型主要有：<ul><li>0x07 表示普通分区(Windows分区、数据分区。默认分区类型)。<li>0xEE 表示该分区表是PMBR，紧随其后的应该是GPT分区表头和GPT分区表，因此这是一块GPT硬盘。<li>0xEF 表示EFI系统分区</ul><p class="line" data-line="64">Petya在解密出原始的MBR后，解析MBR结构，得到起始扇区号，并根据起始扇区定位到DBR。<p class="line" data-line="66">病毒解析MBR时，会对分区类型做判断，如果PMBR和EFI类型的系统分区，默认会不做处理。<p class="line" data-line="68">在010edit工具中查看<p class="text-center line" data-line="70"><img src="/uploads/2017/07/25/cb8ab7085ca7da88a58ab5c86cc1e39c.png" alt="" width="90%"><p class="line" data-line="72">判断分区类型，取了这两个字段：开始扇区与扇区大小：<p class="text-center line" data-line="74"><img src="/uploads/2017/07/25/5bb7e2b71f9cd2a909737c77f19e5e48.png" alt="" width="90%"><p class="line" data-line="76">在启动扇区（也就是63扇区）处，读一个扇区的内容，就是DBR结构<p class="line" data-line="78">从MBR中可以定位到MBR分区表,根据分区表的属性就可以得到活动分区的扇区地址，也就得到了DBR结构地址。<h3 class="line" data-line="80">DBR</h3><p class="line" data-line="82">DBR中存放着关于文件系统的重要参数信息以及系统引导代码。病毒解析到DBR后，只是为了取的DBR结构中的MftStartLcn字段(这个字段表明了MFT结构所在的扇区地址)，以便能进一步定位文件系统。<p class="line" data-line="84">DBR的结构如下：<pre class="hljs"><code class="hljs"> ////////////////////////////////////////////////////////////////////////////  
 //  
 //  NTFS 的DBR 数据结构  
 //  
 ////////////////////////////////////////////////////////////////////////////  
 __typedef__ __struct__ _BIOS_PARAMETER_BLOCK {  
   
  /*+0x0B*/    uint16  BytesPerSector;    // 字节/扇区一般为0x0200 即512  
  /*+0x0D*/    uchar   SectorsPerCluster; // 扇区/簇   
  /*+0x0E*/    uint16  ReservedSectors;   // 保留扇区  
  /*+0x0F*/    uchar   Fats;              //   
  /*+0x11*/    uint16  RootEntries;       //   
  /*+0x13*/    uint16  Sectors;           //   
  /*+0x15*/    uchar   Media;             // 媒介描述  
  /*+0x16*/    uint16  SectorsPerFat;     //   
  /*+0x18*/    uint16  SectorsPerTrack;   // 扇区/磁轨  
  /*+0x1A*/    uint16  Heads;             // 头  
  /*+0x1C*/    uint32  HiddenSectors;     // 隐藏扇区  
  /*+0x20*/    uint32  LargeSectors;      // checked when volume is mounted  
   
 }BIOS_PARAMETER_BLOCK, *pBIOS_PARAMETER_BLOCK;  

__typedef__ __struct__ _NTFS_Boot_Sector{  

  /*+0x00*/  uchar    JmpCode[3];        // 跳转指令  
  /*+0x03*/  __char__     OemID[8];          // 文件系统ID  
  /*+0x0B*/  BIOS_PARAMETER_BLOCK PackedBpb;   // BPB  
  /*+0x24*/  uchar    Unused[4];           // 未使用,总是为  
  /*+0x28*/  uint64   NumberSectors;       // 扇区总数  
  /*+0x30*/  lcn      MftStartLcn;        // 开始C# $MFT  (簇) 乘以 BIOS_PARAMETER_BLOCK.SectorsPerCluster 值得到扇区号  
  /*+0x38*/  lcn      Mft2StartLcn;       // 开始C# $MFTMirr (簇)  
  /*+0x40*/  uchar    ClustersPerFileRecordSegment;  // 文件记录大小指示器  
  /*+0x41*/  uchar   Reserved0[3];       // 未使用  
  /*+0x44*/  uchar DefaultClustersPerIndexAllocationBuffer;     // 簇/索引块  
  /*+0x45*/  uchar   Reserved1[3];       // 未使用  
  /*+0x48*/  uint64  SerialNumber;       // 64位序列号  
  /*+0x50*/  uint32  Checksum;           // 校验和  
  /*+0x54*/  uchar   BootStrap[426];     // 启动代码  
  /*+0x1FE*/ uint16  RecordEndSign;      // 0xAA55 结束标记  
 }NTFS_Boot_Sector, *pNTFS_Boot_Sector;  
</code></pre><p class="line" data-line="129">其中，定位MFT时，最重要的结构为MftStartLcn表示起始簇号，乘以BIOS_PARAMETER_BLOCK.SectorsPerCluster（在我的机器上这个值为8，表示一个簇由8个扇区组成）后就得到起始扇区号。<h3 class="line" data-line="131">MFT</h3><h4 class="line" data-line="133">简介</h4><p class="line" data-line="135">MFT，即主文件表（Master File Table）的简称，它是NTFS文件系统的核心。MFT由一个个MFT项（也称为文件记录）组成。每个MFT项的前部为0x10字节的头结构，用来描述本MFT项的相关信息。后面节存放着属性。每个文件和目录的信息都包含在MFT中，每个文件和目录至少有一个MFT项。除了引导扇区外，访问其他任何一个文件前都需要先访问MFT，在MFT中找到该文件的MFT项，根据MFT项中记录的信息找到文件内容并对其进行访问。<p class="line" data-line="137">MFT结构分为两种：元文件与普通文件。<p class="line" data-line="139">元文件对于用户是不能直接访问的，MFT将开头的16个文件记录块保留用于这些元数据文件，除此之外的文件记录块才用于普通的用户文件和目录。<pre class="hljs"><code class="hljs">#### 16个元文件
#define	MFT_IDX_MFT				0
#define	MFT_IDX_MFT_MIRR		1
#define	MFT_IDX_LOG_FILE		2
#define	MFT_IDX_VOLUME			3
#define	MFT_IDX_ATTR_DEF		4
#define	MFT_IDX_ROOT			5
#define	MFT_IDX_BITMAP			6
#define	MFT_IDX_BOOT			7
#define	MFT_IDX_BAD_CLUSTER		8
#define	MFT_IDX_SECURE			9
#define	MFT_IDX_UPCASE			10
#define	MFT_IDX_EXTEND			11
#define	MFT_IDX_RESERVED12		12
#define	MFT_IDX_RESERVED13		13
#define	MFT_IDX_RESERVED14		14
#define	MFT_IDX_RESERVED15		15
#define	MFT_IDX_USER			16
</code></pre><p class="line" data-line="162">这16个原文件本身也是MFT结构的模式，可以理解为记录了MFT信息的MFT结构。<ul><li><p>怎么解析这16个原文件的MFT结构呢？<ul><li>换句话说，通过MBR定位到DBR,通过DBR定位到MFT，此时的MFT就对应着索引为MFT_IDX_MFT的MFT，向后偏移文件记录大小的地方，就存放着索引为MFT_IDX_MFT_MIRR的MFT。再向后偏移文件记录大小的地方，就存放着索引为MFT_IDX_LOG_FILE的MFT</ul><li><p>解析这16个原文件的MFT结构有什么用？<ul><li>如对于MFT_IDX_VOLUME 这个MFT结构，解析这个MFT结构中的ATTR_TYPE_VOLUME_INFORMATION（对应着0x70）就可以得到NTFS卷的版本信息,解析这个MFT结构中的ATTR_TYPE_VOLUME_NAME属性（对应着0x60）就可以得到NTFS卷名信息。</ul></ul><p class="line" data-line="170">再如，对于MFT_IDX_MFT 这个MFT结构，解析这个MFT结构中的ATTR_TYPE_DATA（对应0x80）的属性RealSize，就表示整个卷所有的文件记录的大小信息。利用这个大小信息是以字节表示的，用这个大小信息除以每个文件记录所占用的字节就得到了卷占有的文件记录数量。计算出来的文件记录数量是将元文件也计算在内的。<p class="line" data-line="172">依次遍历每个文件记录数量，读取这个文件记录的内容就是MFT结构，解析这个MFT的对应属性就可以解析出文件名、文件属性、文件内容等。<h4 class="line" data-line="174">普通MFT</h4><p class="line" data-line="176">遍历文件时，从第16个文件记录开始向后遍历，才会得到普通的用户文件和目录信息及内容。<h4 class="line" data-line="178">数据结构</h4><p class="line" data-line="180">MFT的直观结构如下，<pre class="hljs"><code class="hljs">// 文件记录体
// 属性1
// 属性2
// …………
</code></pre><p class="text-center line" data-line="189"><img src="/uploads/2017/07/25/305f756feed25724d4e439b3ab6bd804.png" alt="" width="75%"><p class="line" data-line="191">每个MFT的结构如下：<pre class="hljs"><code class="hljs">// 文件记录头  
typedef struct _FILE_RECORD_HEADER  
{  
 /*+0x00*/  uint32 Type;            // 固定值'FILE'  
 /*+0x04*/  uint16 UsaOffset;       // 更新序列号偏移, 与操作系统有关  
 /*+0x06*/  uint16 UsaCount;        // 固定列表大小Size in words of Update Sequence Number & Array (S)  
 /*+0x08*/  uint64 Lsn;             // 日志文件序列号(LSN)  
} FILE_RECORD_HEADER, *PFILE_RECORD_HEADER;  
  
// 文件记录体  
typedef struct _FILE_RECORD{  
 /*+0x00*/  FILE_RECORD_HEADER Ntfs;  // MFT表头  
 /*+0x10*/  uint16  SequenceNumber;   // 序列号(用于记录文件被反复使用的次数)  
 /*+0x12*/  uint16  LinkCount;        // 硬连接数  
 /*+0x14*/  uint16  AttributeOffset;  // 第一个属性偏移  
 /*+0x16*/  uint16  Flags;            // falgs, 00表示删除文件,01表示正常文件,02表示删除目录,03表示正常目录  
 /*+0x18*/  uint32  BytesInUse;       // 文件记录实时大小(字节) 当前MFT表项长度,到FFFFFF的长度+4  
 /*+0x1C*/  uint32  BytesAllocated;   // 文件记录分配大小(字节)  
 /*+0x20*/  uint64  BaseFileRecord;   // = 0 基础文件记录 File reference to the base FILE record  
 /*+0x28*/  uint16  NextAttributeNumber; // 下一个自由ID号  
 /*+0x2A*/  uint16  Pading;           // 边界  
 /*+0x2C*/  uint32  MFTRecordNumber;  // windows xp中使用,本MFT记录号  
 /*+0x30*/  uint32  MFTUseFlags;      // MFT的使用标记  
}FILE_RECORD, *pFILE_RECORD;  
</code></pre><p class="line" data-line="220">根据FILE头部数据找到下面的一个个属性,接下来分析的就是一个个属性了，属性由属性头跟属性体组成,属性头的结构定义如下：<pre class="hljs"><code class="hljs">// 属性头  
typedef struct  
{  
 /*+0x00*/  ATTRIBUTE_TYPE AttributeType;    // 属性类型  
 /*+0x04*/  uint16 RecordLength;             // 总长度(Header+body长度)  
 /**0x06*/  uint16 unknow0;  
 /*+0x08*/  uchar Nonresident;               // 非常驻标志  
 /*+0x09*/  uchar NameLength;                // 操作属性名长度  
  
                                          // 0X0001为压缩标记  
                                        // 0X4000为加密标记  
                                        // 0X8000为系数文件标志  
 /*+0x0A*/  uint16 NameOffset;           // 属性名偏移(从属性起始位置的偏移)  
                                              // NameLength 如果不为零,则用这个值去寻址数据偏移  
 /*+0x0C*/  uint16 Flags;                    // ATTRIBUTE_xxx flags.  
 /*+0x0E*/  uint16 AttributeNumber;          // The file-record-unique attribute instance number for this attribute.  
} ATTRIBUTE, *PATTRIBUTE;  
  
// 属性头   
typedef struct _RESIDENT_ATTRIBUTE  
{  
 /*+0x00*/  ATTRIBUTE Attribute;   // 属性  
 /*+0x10*/  uint32 ValueLength;    // Data部分长度  
 /*+0x14*/  uint16 ValueOffset;    // Data内容起始偏移  
 /*+0x16*/  uchar Flags;           // 索引标志  
 /*+0x17*/  uchar Padding0;        // 填充  
} RESIDENT_ATTRIBUTE, *PRESIDENT_ATTRIBUTE;  
</code></pre><p class="line" data-line="252">Petya中涉及到MFT的属性<pre class="hljs"><code class="hljs">// 属性类型定义 
AttributeFileName = 0x30,  
AttributeData = 0x80, 
</code></pre><p class="line" data-line="259">这两个属性的定义如下：<pre class="hljs"><code class="hljs">// 文件属性ATTRIBUTE\.AttributeType == 0x30  
typedef struct  
{  
 /*+0x00*/  uint64 DirectoryFile:48;    // 父目录记录号(前个字节)  
 /*+0x06*/  uint64 ReferenceNumber:16;  // +序列号(与目录相关)  
 /*+0x08*/  uint64 CreationTime;        // 文件创建时间  
 /*+0x10*/  uint64 ChangeTime;          // 文件修改时间          
 /*+0x18*/  uint64 LastWriteTime;       // MFT更新的时间  
 /*+0x20*/  uint64 LastAccessTime;      // 最后一次访问时间  
 /*+0x28*/  uint64 AllocatedSize;       // 文件分配大小  
 /*+0x30*/  uint64 DataSize;            // 文件实际大小  
 /*+0x38*/  uint32 FileAttributes;      // 标志,如目录压缩隐藏等  
 /*+0x3C*/  uint32 AlignmentOrReserved; // 用于EAS和重解析  
 /*+0x40*/  uchar NameLength;      // 以字符计的文件名长度,没字节占用字节数由下一字节命名空间确定  
  
            // 文件名命名空间, 0 POSIX大小写敏感,1 win32空间,2 DOS空间, 3 win32&DOS空间  
 /*+0x41*/  uchar NameType;          
 /*+0x42*/  wchar Name[1];         // 以Unicode方式标识的文件名  
} FILENAME_ATTRIBUTE, *PFILENAME_ATTRIBUTE;  
  
// 数据流属性 ATTRIBUTE.AttributeType == 0x80   
typedef struct _NONRESIDENT_ATTRIBUTE  
{  
    /*+0x00*/   ATTRIBUTE Attribute;    
  
    /*+0x10*/   uint64 StartVcn;     // LowVcn 起始VCN  起始簇号  
    /*+0x18*/   uint64 LastVcn;      // HighVcn  结束VCN  结束簇号  
  
    /*+0x20*/   uint16 RunArrayOffset;    // 数据运行的偏移，非常重要 
    /*+0x22*/   uint16 CompressionUnit;   // 压缩引擎  
    /*+0x24*/   uint32  Padding0;       // 填充  
    /*+0x28*/   uint32  IndexedFlag;    // 为属性值分配大小(按分配的簇的字节数计算)  
    /*+0x30*/   uint64 AllocatedSize;   // 属性值实际大小  
    /*+0x38*/   uint64 DataSize;     // 属性值压缩大小  
    /*+0x40*/   uint64 InitializedSize;   // 实际数据大小  
    /*+0x48*/   uint64 CompressedSize;    // 压缩后大小  
} NONRESIDENT_ATTRIBUTE, *PNONRESIDENT_ATTRIBUTE;  
</code></pre><ul><li>对于0x30属性：</ul><p class="line" data-line="303">对于MFT中的0x30属性的直观认识，如下：<p class="line" data-line="305">黄色部分对应着上表中的ATTRIBUTE结构，红色部分对应着上表中的NONRESIDENT_ATTRIBUTE结构。选中部分对应着FILENAME_ATTRIBUTE结构内容，这里面包含了文件的各种时间属性和文件名等内容。<p class="text-center line" data-line="307"><img src="/uploads/2017/07/25/83f1f40efdf04df7bb760b0299c90b61.png" alt="" width="90%"><p class="line" data-line="309">Petya病毒在遍历MFT时，会通过判断当前MFT的AttributeFileName属性判断是否加密该MFT。<ul><li>对于0x80属性：</ul><p class="line" data-line="313">对于MFT中的0x80属性的直观认识，如下：<p class="line" data-line="315">黄色部分对应着上表中的ATTRIBUTE结构，红色部分对应着上表中的NONRESIDENT_ATTRIBUTE结构。绿色部分对应着RUN-LIST结构内容。<p class="text-center line" data-line="317"><img src="/uploads/2017/07/25/0aa26858b723e9404715e63d982d3cf3.png" alt="" width="90%"><p class="line" data-line="319">80H属性是文件数据属性，该属性容纳着文件的内容，文件的大小一般指的就是未命名数据流的大小。该属性没有最大最小限制，最小情况是该属性为常驻属性。常驻属性就不做多的解释了，如下是一个非常驻的80H属性。<p class="line" data-line="321">该属性的“Run List”值为“32 0C 1B 00 00 0C”，其具体含义如下：<p class="text-center line" data-line="323"><img src="/uploads/2017/07/25/11ec3809e86bab9c742003855fe4a065.png" alt="" width="90%"><p class="line" data-line="325">Petya病毒在加密文件内容时，会通过Run List定位到文件内容所在的真正扇区加密文件，如果文件内容大于2个扇区，则只加密前两个扇区。<h2 class="line" data-line="327">恶意代码加载过程</h2><h3 class="line" data-line="329">1 加载代码到0x8000执行</h3><p class="line" data-line="331">从第一个扇区开始，读取0x20个扇区到0x8000地址处，随后跳到0x8000处执行<p class="line" data-line="333">循环读取0x20个扇区代码片段：<p class="text-center line" data-line="335"><img src="/uploads/2017/07/25/f1ddca4af289916c2eaa3b5fd527c52e.png" alt="" width="90%"><p class="line" data-line="337">在循环里使用int 13读取磁盘内容<p class="text-center line" data-line="339"><img src="/uploads/2017/07/25/d517cab4208845fae0a933191f17768a.png" alt=""><h3 class="line" data-line="341">2 调用函数读取硬盘参数</h3><p class="line" data-line="343">读取硬盘参数<p class="text-center line" data-line="345"><img src="/uploads/2017/07/25/bc1e54d9ac8e7f62081cce176f621822.png" alt="" width="90%"><p class="line" data-line="347">比较“FA 31 C0 8E”硬编码，判断当前的第一个扇区的内容是不是病毒写入的内容。<p class="text-center line" data-line="349"><img src="/uploads/2017/07/25/f989c9b49aca1fbef95fb2ed13ac55ca.png" alt="" width="90%"><h3 class="line" data-line="351">判断加密标志</h3><p class="line" data-line="353">读取0x20扇区的内容（该扇区保存了病毒的配置信息），判断该扇区的第一个字节是不是1，如果是1，表示mbr已经被加过密，就来到显示勒索界面的流程;如果不为1，表示还未对MBR和MFT进行加密，进入加密流程。<p class="text-center line" data-line="355"><img src="/uploads/2017/07/25/51d51b4c39e024fbb002d0a762828a41.png" alt="" width="99%"><h2 class="line" data-line="357">加密过程</h2><h3 class="line" data-line="359">1 打印修复磁盘信息，设置加密标志</h3><p class="line" data-line="361">打印出虚假的“Repairing file system on C:”信息，读取0x20扇区中的配置信息到内存，并将读取到的配置信息的加密标志设置为1。随后，将修改过加密标志的内容写入到扇区中，为了保证写入成功，这里循环写了0x20次。<p class="line" data-line="363">打印的磁盘修复信息如下：<p class="text-center line" data-line="365"><img src="/uploads/2017/07/25/fec6399d07d526a8fb688c8e4f54e1de.png" alt="" width="90%"><p class="text-center line" data-line="367"><img src="/uploads/2017/07/25/d514c1f5da08dc7fa6f656986c5a6564.png" alt="" width="90%"><h3 class="line" data-line="369">2 加密验证扇区</h3><p class="line" data-line="371">加密验证扇区的方法为：读取0x21扇区的内容（这个扇区保存的全是0x07数据），使用从配置信息扇区读取的key与n做为加密参数，调用salsa加密该读到的0x07内容，并将加密后的内容写入到0x21扇区中<p class="text-center line" data-line="373"><img src="/uploads/2017/07/25/5c0b22a8b5c23f1824f9da08267a83e0.png" alt="" width="90%"><p class="text-center line" data-line="375"><img src="/uploads/2017/07/25/099a8b6797c6401eabdb1efdd1b67b50.png" alt="" width="90%"><p class="line" data-line="377">显示虚假的“CHKDSK is repairing sector”界面，实际在后台正在加密MFT数据。<p class="text-center line" data-line="379"><img src="/uploads/2017/07/25/9c27e3f0dcce5beaa74b5f250f5ca44d.png" alt="" width="90%"><h3 class="line" data-line="381">3 加密操作</h3><h4 class="line" data-line="383">文件遍历的原理</h4><p class="line" data-line="385">Petya病毒通过解析MBR，DBR得到MFT地址。解析MFT索引为0的元文件，得到属性为DATA的属性内容，取出属性中的RUN-LIST结构中的簇数量与起始扇区，根据这两个字段遍历所有的MFT就得到了当前文件系统中所有的文件信息。<ol><li>解析MBR</ol><p class="line" data-line="389">解析原始MBR数据的代码片段：<p class="text-center line" data-line="391"><img src="/uploads/2017/07/25/c492c18191fb7333811c8d541a91f200.png" alt="" width="90%"><p class="line" data-line="393">判断MBR中的分区类型：<p class="text-center line" data-line="395"><img src="/uploads/2017/07/25/84c682ad0195067b28cdd0b6f7f9a7f0.png" alt="" width="90%"><p class="line" data-line="397">判断从mbr中读取到的StartLBA字段不为空<p class="text-center line" data-line="399"><img src="/uploads/2017/07/25/7d4060cd86c75d892c4f283b6f10ad1c.png" alt="" width="90%"><p class="line" data-line="401">从mbr中解析到StartLBA字段，并读取该字段对应的扇区，此扇区的内容就为DBR相关的内容：<p class="text-center line" data-line="403"><img src="/uploads/2017/07/25/b423cd8965358de2784a89331806ba14.png" alt="" width="90%"><p class="line" data-line="405">读取到DBR后，解析出MftStartLcn字段，该字段就表示 MFT地址：<p class="text-center line" data-line="407"><img src="/uploads/2017/07/25/9b006a175eec0a34093758e0ae23b111.png" alt="" width="90%"><p class="line" data-line="410">得到MFT地址后，该地址就是索引为0的MFT元文件地址,从该元文件结构中取出属性为0x80（DATA）的内容，<p class="line" data-line="412">首先读取到$MFT的扇区内容：<p class="text-center line" data-line="414"><img src="/uploads/2017/07/25/df5a5ee6c0ac0eba3a364436009c9a8a.png" alt="" width="90%"><p class="line" data-line="416">解析属性，判断是不是0x80(DATA)属性类型<p class="text-center line" data-line="418"><img src="/uploads/2017/07/25/d8d49240c8840d7173ba6395017b4cef.png" alt="" width="90%"><p class="line" data-line="420">对$MFT属性0x80中的解析，得到下面信息：<p class="line" data-line="422">run_data_cluster*sector/cluster + 0x20(0x20为元文件占用的扇区大小)+mbr. arg_StartLBA，作为普通 MFT扇区的起始扇区，这样是保证加密的过程中不会加密元文件扇区与mbr相关的扇区。<p class="line" data-line="424">（run_data_num_clusters * sector/cluster）- 0x20(0x20为元文件占用的扇区大小)，做为普通MFT的扇区大小<p class="text-center line" data-line="426"><img src="/uploads/2017/07/25/c8a6dc7b98daaf4b564a84671e995644.png" alt="" width="90%"><p class="line" data-line="428">随后，就来到遍历用户MFT的函数：<p class="text-center line" data-line="430"><img src="/uploads/2017/07/25/a8b85a6edc3806c80fab3c03f24cde45.png" alt="" width="90%"><h4 class="line" data-line="433">遍历普通MFT结构</h4><p class="line" data-line="435">遍历普通MFT结构的函数在00008FA6处，该函数为病毒代码中最为主要的函数。<p class="line" data-line="437">下面对这个函数进行详细分析:<p class="line" data-line="439">在调试的过程中，parse_User_MFT函数的参数内容为：80 C6 5F 00 60 00 20 C6 00 00 3F 00 00 00 3F 00 60 00 08 C6 2C 67 4A 67 8B 77 52 9C 01,结合调试时传递的参数内容，对函数作出说明。<table><thead><tr><th>参数<th>类型<th>数据<th>功能<tbody><tr><td>dir_num<td>WORD<td>80 C6<td>只取了第一字节80使用，在通过int 13读写扇区内容使用到<tr><td>abase_sector<td>DWORD<td>5F 00 60 00<td>普通MFT的起始扇区<tr><td>TotalSetorNum<td>WORD<td>20 C6<td>普通MFT扇区数量<tr><td>show_char<td>WORD<td>00 00<td>用于屏幕显示<tr><td>StartLBA<td>DWORD<td>3F 00 00 00<td>从mbr中解析出的startLBA字段，在加密过程中，如果MFT的数据内容在startLBA扇区内，就跳过到此扇区的加密，防止误把mbr重要数据加密<tr><td>arg_E<td><td>3F 00 60 00<td>没使用<tr><td>SectorsPerCluster<td>WORD<td>08 C6<td>只取了第一字节08使用，从dbr中解析出来的SectorsPerCluster字段，表示每簇的扇区数量<tr><td>p_encrypt_num<td>WORD<td>2C 67<td>用来存放当前已经加密的扇区数量的缓冲区<tr><td>salsa_key<td>WORD<td>4A 67<td>salsa算法使用的KEY<tr><td>arg_iv<td>WORD<td>8B 77<td>salsa算法使用的 IV<tr><td>CharShow<td>WORD<td>52 9C<td>用于显示界面字符<tr><td>arg_flag<td>WORD<td>01 00<td>标志位，只是标志位为1时，才会加密</table><p class="line" data-line="456">该函数主要功能为：对扇区中的MFT遍历，对不符合MFT头部标志(FILE)的扇区，会直接调用SALSA20算法进行加密该扇区，对符合MFT头部标志的扇区，判断0x30属性中的文件名判断是不是元文件，如果不是元文件名格式，则直接加密该扇区。其他情况下，判断MFT结构0x80属性中的常驻内存属性，如果是非常驻内存属性，就解析文件内容的前二个扇区，取出该扇区的内容后，使用salsa20算法进行加密。<ol><li>先打印出“CHKDSK is repairing sector”，显示虚假的磁盘修复界面</ol><p class="text-center line" data-line="460"><img src="/uploads/2017/07/25/a3977b49aeeb8e36a8332e627645cea8.png" alt="" width="90%"><ol start="2"><li>对当前MFT头是不是“FILE”,如果不是”FILE”的话，则直接加密这个扇区</ol><p class="text-center line" data-line="464"><img src="/uploads/2017/07/25/a4d9951bee67fcc18d8b0f8628c1096d.png" alt="" width="90%"><ol start="3"><li>如果是FILE，接着遍历mft的各个属性：</ol><p class="line" data-line="468">如果属性为AttributeFileName（0x30），判断文件名字长度是不是1，如果长度为1，直接加密，如果长度不为1，则看文件名字是不是以$开头(以$开头的是NTFS文件系统的元文件)，如果是元文件，则加密当前MFT.<p class="text-center line" data-line="470"><img src="/uploads/2017/07/25/5ae904203b51d0c92e4885290661f3df.png" alt="" width="90%"><p class="line" data-line="472">如果属性为AttributeData文件数据属性（0x80），则首先根据属性头判断是不是非常驻内存，如果是常驻内存属性就跳过，不进行加密。如果是非常驻内存属性，则通过RUNLIST结构遍历到存储数据的真正的扇区位置。<p class="text-center line" data-line="474"><img src="/uploads/2017/07/25/159054d773680803f830463365c03cfe.png" alt="" width="90%"><p class="line" data-line="476">解析RUNLIST<p class="text-center line" data-line="478"><img src="/uploads/2017/07/25/6c00d5bf3e6c19a7b357c44d0fb3644f.png" alt="" width="90%"><p class="line" data-line="480">根据RUNLIST中的起始簇乘以MBR中保存的每簇对应的扇区数，得到数据真正所在的扇区。<p class="text-center line" data-line="482"><img src="/uploads/2017/07/25/4eada2539c1ad8192fba15a8dd2e16d9.png" alt="" width="90%"><p class="line" data-line="484">随后，判断上面计算出的文件内容对应扇区数量是不是大于2，如果大于2，只加密前2个扇区。<p class="text-center line" data-line="486"><img src="/uploads/2017/07/25/56b174bbd4c6ebd2af741ba73260282f.png" alt="" width="90%"><p class="line" data-line="488">读取该MFT文件对应的文件内容的前两个分区，通过直接使用int 13中断从扇区读取到文件内容，使用salsa20加密后，将密文直接写入的扇区中文件中。<p class="text-center line" data-line="490"><img src="/uploads/2017/07/25/21f61a8ad162b6b73788d7af063ac414.png" alt="" width="90%"><p class="line" data-line="492">在动态调试时，可以看到加密了文件内容，加密文件内容前的数据<p class="text-center line" data-line="494"><img src="/uploads/2017/07/25/8bd29bd4aaf54f20469012557b8ead84.png" alt="" width="90%"><p class="line" data-line="496">被加密后的文件内容：<p class="text-center line" data-line="498"><img src="/uploads/2017/07/25/15be20fa0ee6c89862caf40abd228189.png" alt="" width="90%"><h4 class="line" data-line="500">加密函数</h4><p class="line" data-line="502">对文件的加密使用了SALSA20算法，该算法属于流加密，在知道key和iv的情况下，加密函数和解密函数可以为相同的函数代码。<p class="line" data-line="504">加密函数<p class="text-center line" data-line="506"><img src="/uploads/2017/07/25/d891c0f3a128dfdca4ab9349aa61ea23.png" alt="" width="90%"><p class="line" data-line="508">在密钥扩展的函数中，Petya将原始的常数“expand 16-byte k”更改成了“1nvald s3ct”<p class="line" data-line="510">扩展密钥函数代码：<p class="text-center line" data-line="512"><img src="/uploads/2017/07/25/7513b898e9fe11f17806a9bc0614ba1a.png" alt="" width="90%"><p class="line" data-line="514">Salsa20加密时使用的key和iv来自于配置信息扇区（0x20扇区）<p class="text-center line" data-line="516"><img src="/uploads/2017/07/25/10f91c1a321dc37c419c4c5a1261c93c.png" alt="" width="90%"><p class="line" data-line="518">将明文与生成的keystream异或，实现加密<p class="text-center line" data-line="520"><img src="/uploads/2017/07/25/ffa6ee8604e5c1f1e5edc53e34aaedf9.png" alt="" width="90%"><h2 class="line" data-line="522">解密过程</h2><p class="line" data-line="524">在开机启动过程中，MBR引导后，加载扇区中的恶意代码后，恶意代码会判断配置信息第1个BYTE是不是1，1表示已经加密过，则进入相应的解密过程中<h3 class="line" data-line="526">1 打印勒索信息</h3><p class="line" data-line="528">打印出勒索信息<p class="text-center line" data-line="530"><img src="/uploads/2017/07/25/11d9442b024acdf131fa400c6998621f.png" alt="" width="90%"><p class="line" data-line="532">也就是显示如下的内容<p class="text-center line" data-line="534"><img src="/uploads/2017/07/25/2d538d7d1f8876cdf572e1a7f49ba437.png" alt="" width="90%"><h3 class="line" data-line="536">2 读取用户输入的key</h3><p class="line" data-line="538">清空内存，读取用户输入的key<p class="text-center line" data-line="540"><img src="/uploads/2017/07/25/48e5dec1ad001bd80cea9e9a7c964cff.png" alt="" width="90%"><h3 class="line" data-line="542">3 验证用户的key</h3><p class="line" data-line="544">在验证KEY的过程中，首先比较输入的key的长度，必须大于0x20长度<p class="text-center line" data-line="546"><img src="/uploads/2017/07/25/ee5cc109d25593ee2c716d4f3e249d10.png" alt="" width="90%"><p class="line" data-line="548">将输入的key通过自定义算法的转换	0x21次<p class="text-center line" data-line="550"><img src="/uploads/2017/07/25/fb925063f3e363646b5ea38a27906542.png" alt="" width="90%"><p class="line" data-line="552">使用转换过的key，使用salsa20算法解密0x21扇区的内容（这个扇区的内容为加密过的0x7内容），比较解密出来的内容是不是0x7，如果是则表明解密密码正确。<p class="text-center line" data-line="554"><img src="/uploads/2017/07/25/edd5fa6f10c48cb40a0b1180dce7091b.png" alt="" width="90%"><p class="text-center line" data-line="556"><img src="/uploads/2017/07/25/59681650ad38f20124784eb166f401a7.png" alt="" width="90%"><p class="line" data-line="558">密码验证通过后，会使用这个key做为参数调用DecryptProc 函数(并非勒索软件作者定义的函数名)，<p class="text-center line" data-line="560"><img src="/uploads/2017/07/25/dcd446cbfc5100c94540914a8678b920.png" alt="" width="90%"><p class="line" data-line="562">在DecryptProc函数中调用与加密时相同的函数进行对MFT结构进行遍历后解密，<p class="text-center line" data-line="564"><img src="/uploads/2017/07/25/7e511a9d53033224983402b4f516a926.png" alt="" width="90%"><p class="line" data-line="566">在解密完成后，打印“Please reboot your computer!”信息<p class="text-center line" data-line="568"><img src="/uploads/2017/07/25/dcc15ec5f0d71412c6c3a571997689d6.png" alt="" width="90%"><h2 class="line" data-line="570">总结</h2><p class="line" data-line="572">本文对Petya变种勒索蠕虫的扇区启动代码进行了详细分析，分析显示Petya变种勒索蠕虫并不仅会加密MBR和MFT结构，也会将MFT对应的文件内容的前两个扇区进行加密。换句话说，Petya变种勒索蠕虫在系统启动时MBR中的代码执行时也会进行全盘文件的加密操作。结合RING3级别的勒索代码功能，Petya会对文件执行两次加密操作，第一次为Petya勒索蠕虫执行时，使用RSA与AES算法遍历文件系统对指定扩展名的文件加密，第二次为系统启动时，启动扇区的代码会通过遍历MFT结构定位文件内容并对文件使用salsa20算法进行加密。对于RING3级别的文件加密过程，解密密钥可以通过勒索蠕虫作者的RSA私钥进行解密获得，而启动扇区级别的文件加密过程使用了随机密码进行，启动扇区级别的文件加密无法解密。<h2 class="line" data-line="574">参考</h2><p class="line" data-line="576"><a href="http://dengqi.blog.51cto.com/5685776/1351300">http://dengqi.blog.51cto.com/5685776/1351300</a><p class="line" data-line="578"><a href="https://github.com/alexwebr/salsa20/blob/master/salsa20.c">https://github.com/alexwebr/salsa20/blob/master/salsa20.c</a><p class="line" data-line="580"><a href="http://blog.csdn.net/enjoy5512/article/details/50966009">http://blog.csdn.net/enjoy5512/article/details/50966009</a><p class="line" data-line="582"><a href="http://bobao.360.cn/learning/detail/4039.html">http://bobao.360.cn/learning/detail/4039.html</a></div><div class="back-top" data-v-8db87e62></div></div></section></div></div><script type="text/javascript">window.__NUXT__={layout:"default",data:[{articleData:{_id:"597733a71c670a09e493ee40",title:"Petya变种勒索蠕虫启动代码分析",category:"事件追踪",readableId:"analysis-of-petya-boot-code",abstract:"继5月的WannaCry勒索蠕虫事件以后，2017年6月又出现了Petya变种勒索蠕虫，除了利用永恒之蓝漏洞和加密勒索以后，Petya变种与WannaCry有比较大的差别。WannaCry会加密机器上的文件，导致数据损毁，而Petya更为激进，它会加密系统的MBR直接导致机器无法启动，本文对其执行的MBR及文件系统的加密机制做详细的分析。",author:"马茂刚",headImg:"/uploads/2017/08/17/6f753d60b82a62ef66be632f502646cc.png",descImg:"/uploads/2017/07/30/5abbf430bedd308ef9d6ff5623ee2961.png",tags:["mbr","petya"],publish_time:"2017-07-27T11:30:08.281Z",content:'<h1 class="line" data-line="0">背景</h1>\n<p class="line" data-line="2">继5月的WannaCry勒索蠕虫事件以后，2017年6月又出现了Petya变种勒索蠕虫，除了利用永恒之蓝漏洞和加密勒索以后，Petya变种与WannaCry有比较大的差别。WannaCry会加密机器上的文件，导致数据损毁，而Petya更为激进，它会加密系统的MBR直接导致机器无法启动，本文对其执行的MBR及文件系统的加密机制做详细的分析。</p>\n<h1 class="line" data-line="4">恶意代码分析</h1>\n<p class="line" data-line="6">由于执行恶意操作的指令并不是以文件形式存在，我们使用WinHex工具提取受攻击机器的磁盘前23个扇区的数据进行分析，对应代码数据的Hash为 841e12729f200a5620859f2958e2d484。</p>\n<h2 class="line" data-line="8">相关数据结构</h2>\n<p class="line" data-line="10">计算机启动时执行完BIOS的启动代码，检查各硬件设备正常后，JMP到MBR的引导代码进行执行；然后由MBR引导至活动分区的DBR，再由DBR引导操作系统。如：DBR调用NTLDR，再由NTLDR调用系统内核。</p>\n<p class="line" data-line="12">Petya病毒修改了系统的MBR，病毒在Bios加载后获得执行机会，病毒将加载存储在0x1扇区后的大小为0x20大小的病毒代码加载执行，这些代码会还原出真实的MBR，通过对还原出来的MBR解析，得到系统的DBR，通过DBR解析到系统的MFT结构，遍历所有的MFT，根据MFT找到文件内容所在的扇区后，读取该扇区加密内容后再写回到扇区中，从而实现对文件的加密。要完整的了解整个的加密过程，首先就是熟悉系统的MBR、DBR、MFT等结构的含义与功能。</p>\n<h3 class="line" data-line="14">MBR</h3>\n<p class="line" data-line="16">Petya病毒修改了系统的MBR，病毒在Bios加载后获得执行机会，病毒将加载存储在0x1扇区后的大小为0x20大小的病毒代码加载执行，这些代码会还原出真实的MBR。在加密文件的过程中，Petya病毒会使用到MBR中</p>\n<p class="line" data-line="18">MBR扇区由以下四部分组成：</p>\n<ul>\n<li>引导代码：引导代码占MBR分区的前440字节，负责整个系统启动。如果引导代码被破坏，系统将无法启动。</li>\n<li>Windows磁盘签名：占引导代码后面的4字节，是Windows初始化磁盘写入的磁盘标签，如果此标签被破坏，则系统会提示“初始化磁盘”。</li>\n<li>MBR分区表：占Windows磁盘标签后面的64个字节，是整个硬盘的分区表。</li>\n<li>MBR结束标志：占MBR扇区最后2个字节，一直为“55 AA”。</li>\n</ul>\n<p class="line" data-line="25">MBR结构如下：</p>\n<pre class="hljs"><code class="hljs">;====================================================================\n    主引导记录(MBR)结构\n;====================================================================\n typedef struct _MASTER_BOOT_RECORD\n {\n  UCHAR    BootCode[446];\n  PARTITION_ENTRY  Partition[4];\n  USHORT    Signature;\n }MASTER_BOOT_RECORD,*PMASTER_BOOT_RECORD;\n \n;====================================================================\n;====================================================================\n     分区表项结构(16字节)\n;====================================================================\n \n typedef struct _PARTITION_ENTRY\n {\n  UCHAR BootIndicator;  // 能否启动标志\n  UCHAR StartHead;   // 该分区起始磁头号\n  UCHAR StartSector;  // 起始柱面号高2位：6位起始扇区号\n  UCHAR StartCylinder;  // 起始柱面号低8位\n  UCHAR PartitionType;  // 分区类型\n  UCHAR EndHead;   // 该分区终止磁头号\n  UCHAR EndSector;   // 终止柱面号高2位：6位终止扇区号\n  UCHAR EndCylinder;  // 终止柱面号低8位\n  ULONG StartLBA;   // 起始扇区号\n  ULONG TotalSector;  // 分区尺寸（总扇区数）\n }PARTITION_ENTRY,*PPARTITION_ENTRY;\n</code></pre>\n<p class="line" data-line="58">对于其中的PartitionType 字段，Windows下可识别的分区类型主要有：</p>\n<ul>\n<li>0x07 表示普通分区(Windows分区、数据分区。默认分区类型)。</li>\n<li>0xEE 表示该分区表是PMBR，紧随其后的应该是GPT分区表头和GPT分区表，因此这是一块GPT硬盘。</li>\n<li>0xEF 表示EFI系统分区</li>\n</ul>\n<p class="line" data-line="64">Petya在解密出原始的MBR后，解析MBR结构，得到起始扇区号，并根据起始扇区定位到DBR。</p>\n<p class="line" data-line="66">病毒解析MBR时，会对分区类型做判断，如果PMBR和EFI类型的系统分区，默认会不做处理。</p>\n<p class="line" data-line="68">在010edit工具中查看</p>\n<p class="text-center line" data-line="70"><img src="/uploads/2017/07/25/cb8ab7085ca7da88a58ab5c86cc1e39c.png" alt="" width="90%"></p>\n<p class="line" data-line="72">判断分区类型，取了这两个字段：开始扇区与扇区大小：</p>\n<p class="text-center line" data-line="74"><img src="/uploads/2017/07/25/5bb7e2b71f9cd2a909737c77f19e5e48.png" alt="" width="90%"></p>\n<p class="line" data-line="76">在启动扇区（也就是63扇区）处，读一个扇区的内容，就是DBR结构</p>\n<p class="line" data-line="78">从MBR中可以定位到MBR分区表,根据分区表的属性就可以得到活动分区的扇区地址，也就得到了DBR结构地址。</p>\n<h3 class="line" data-line="80">DBR</h3>\n<p class="line" data-line="82">DBR中存放着关于文件系统的重要参数信息以及系统引导代码。病毒解析到DBR后，只是为了取的DBR结构中的MftStartLcn字段(这个字段表明了MFT结构所在的扇区地址)，以便能进一步定位文件系统。</p>\n<p class="line" data-line="84">DBR的结构如下：</p>\n<pre class="hljs"><code class="hljs"> ////////////////////////////////////////////////////////////////////////////  \n //  \n //  NTFS 的DBR 数据结构  \n //  \n ////////////////////////////////////////////////////////////////////////////  \n __typedef__ __struct__ _BIOS_PARAMETER_BLOCK {  \n   \n  /*+0x0B*/    uint16  BytesPerSector;    // 字节/扇区一般为0x0200 即512  \n  /*+0x0D*/    uchar   SectorsPerCluster; // 扇区/簇   \n  /*+0x0E*/    uint16  ReservedSectors;   // 保留扇区  \n  /*+0x0F*/    uchar   Fats;              //   \n  /*+0x11*/    uint16  RootEntries;       //   \n  /*+0x13*/    uint16  Sectors;           //   \n  /*+0x15*/    uchar   Media;             // 媒介描述  \n  /*+0x16*/    uint16  SectorsPerFat;     //   \n  /*+0x18*/    uint16  SectorsPerTrack;   // 扇区/磁轨  \n  /*+0x1A*/    uint16  Heads;             // 头  \n  /*+0x1C*/    uint32  HiddenSectors;     // 隐藏扇区  \n  /*+0x20*/    uint32  LargeSectors;      // checked when volume is mounted  \n   \n }BIOS_PARAMETER_BLOCK, *pBIOS_PARAMETER_BLOCK;  \n\n__typedef__ __struct__ _NTFS_Boot_Sector{  \n\n  /*+0x00*/  uchar    JmpCode[3];        // 跳转指令  \n  /*+0x03*/  __char__     OemID[8];          // 文件系统ID  \n  /*+0x0B*/  BIOS_PARAMETER_BLOCK PackedBpb;   // BPB  \n  /*+0x24*/  uchar    Unused[4];           // 未使用,总是为  \n  /*+0x28*/  uint64   NumberSectors;       // 扇区总数  \n  /*+0x30*/  lcn      MftStartLcn;        // 开始C# $MFT  (簇) 乘以 BIOS_PARAMETER_BLOCK.SectorsPerCluster 值得到扇区号  \n  /*+0x38*/  lcn      Mft2StartLcn;       // 开始C# $MFTMirr (簇)  \n  /*+0x40*/  uchar    ClustersPerFileRecordSegment;  // 文件记录大小指示器  \n  /*+0x41*/  uchar   Reserved0[3];       // 未使用  \n  /*+0x44*/  uchar DefaultClustersPerIndexAllocationBuffer;     // 簇/索引块  \n  /*+0x45*/  uchar   Reserved1[3];       // 未使用  \n  /*+0x48*/  uint64  SerialNumber;       // 64位序列号  \n  /*+0x50*/  uint32  Checksum;           // 校验和  \n  /*+0x54*/  uchar   BootStrap[426];     // 启动代码  \n  /*+0x1FE*/ uint16  RecordEndSign;      // 0xAA55 结束标记  \n }NTFS_Boot_Sector, *pNTFS_Boot_Sector;  \n</code></pre>\n<p class="line" data-line="129">其中，定位MFT时，最重要的结构为MftStartLcn表示起始簇号，乘以BIOS_PARAMETER_BLOCK.SectorsPerCluster（在我的机器上这个值为8，表示一个簇由8个扇区组成）后就得到起始扇区号。</p>\n<h3 class="line" data-line="131">MFT</h3>\n<h4 class="line" data-line="133">简介</h4>\n<p class="line" data-line="135">MFT，即主文件表（Master File Table）的简称，它是NTFS文件系统的核心。MFT由一个个MFT项（也称为文件记录）组成。每个MFT项的前部为0x10字节的头结构，用来描述本MFT项的相关信息。后面节存放着属性。每个文件和目录的信息都包含在MFT中，每个文件和目录至少有一个MFT项。除了引导扇区外，访问其他任何一个文件前都需要先访问MFT，在MFT中找到该文件的MFT项，根据MFT项中记录的信息找到文件内容并对其进行访问。</p>\n<p class="line" data-line="137">MFT结构分为两种：元文件与普通文件。</p>\n<p class="line" data-line="139">元文件对于用户是不能直接访问的，MFT将开头的16个文件记录块保留用于这些元数据文件，除此之外的文件记录块才用于普通的用户文件和目录。</p>\n<pre class="hljs"><code class="hljs">#### 16个元文件\n#define\tMFT_IDX_MFT\t\t\t\t0\n#define\tMFT_IDX_MFT_MIRR\t\t1\n#define\tMFT_IDX_LOG_FILE\t\t2\n#define\tMFT_IDX_VOLUME\t\t\t3\n#define\tMFT_IDX_ATTR_DEF\t\t4\n#define\tMFT_IDX_ROOT\t\t\t5\n#define\tMFT_IDX_BITMAP\t\t\t6\n#define\tMFT_IDX_BOOT\t\t\t7\n#define\tMFT_IDX_BAD_CLUSTER\t\t8\n#define\tMFT_IDX_SECURE\t\t\t9\n#define\tMFT_IDX_UPCASE\t\t\t10\n#define\tMFT_IDX_EXTEND\t\t\t11\n#define\tMFT_IDX_RESERVED12\t\t12\n#define\tMFT_IDX_RESERVED13\t\t13\n#define\tMFT_IDX_RESERVED14\t\t14\n#define\tMFT_IDX_RESERVED15\t\t15\n#define\tMFT_IDX_USER\t\t\t16\n</code></pre>\n<p class="line" data-line="162">这16个原文件本身也是MFT结构的模式，可以理解为记录了MFT信息的MFT结构。</p>\n<ul>\n<li>\n<p>怎么解析这16个原文件的MFT结构呢？</p>\n<ul>\n<li>换句话说，通过MBR定位到DBR,通过DBR定位到MFT，此时的MFT就对应着索引为MFT_IDX_MFT的MFT，向后偏移文件记录大小的地方，就存放着索引为MFT_IDX_MFT_MIRR的MFT。再向后偏移文件记录大小的地方，就存放着索引为MFT_IDX_LOG_FILE的MFT</li>\n</ul>\n</li>\n<li>\n<p>解析这16个原文件的MFT结构有什么用？</p>\n<ul>\n<li>如对于MFT_IDX_VOLUME 这个MFT结构，解析这个MFT结构中的ATTR_TYPE_VOLUME_INFORMATION（对应着0x70）就可以得到NTFS卷的版本信息,解析这个MFT结构中的ATTR_TYPE_VOLUME_NAME属性（对应着0x60）就可以得到NTFS卷名信息。</li>\n</ul>\n</li>\n</ul>\n<p class="line" data-line="170">再如，对于MFT_IDX_MFT 这个MFT结构，解析这个MFT结构中的ATTR_TYPE_DATA（对应0x80）的属性RealSize，就表示整个卷所有的文件记录的大小信息。利用这个大小信息是以字节表示的，用这个大小信息除以每个文件记录所占用的字节就得到了卷占有的文件记录数量。计算出来的文件记录数量是将元文件也计算在内的。</p>\n<p class="line" data-line="172">依次遍历每个文件记录数量，读取这个文件记录的内容就是MFT结构，解析这个MFT的对应属性就可以解析出文件名、文件属性、文件内容等。</p>\n<h4 class="line" data-line="174">普通MFT</h4>\n<p class="line" data-line="176">遍历文件时，从第16个文件记录开始向后遍历，才会得到普通的用户文件和目录信息及内容。</p>\n<h4 class="line" data-line="178">数据结构</h4>\n<p class="line" data-line="180">MFT的直观结构如下，</p>\n<pre class="hljs"><code class="hljs">// 文件记录体\n// 属性1\n// 属性2\n// …………\n</code></pre>\n<p class="text-center line" data-line="189"><img src="/uploads/2017/07/25/305f756feed25724d4e439b3ab6bd804.png" alt="" width="75%"></p>\n<p class="line" data-line="191">每个MFT的结构如下：</p>\n<pre class="hljs"><code class="hljs">// 文件记录头  \ntypedef struct _FILE_RECORD_HEADER  \n{  \n /*+0x00*/  uint32 Type;            // 固定值\'FILE\'  \n /*+0x04*/  uint16 UsaOffset;       // 更新序列号偏移, 与操作系统有关  \n /*+0x06*/  uint16 UsaCount;        // 固定列表大小Size in words of Update Sequence Number & Array (S)  \n /*+0x08*/  uint64 Lsn;             // 日志文件序列号(LSN)  \n} FILE_RECORD_HEADER, *PFILE_RECORD_HEADER;  \n  \n// 文件记录体  \ntypedef struct _FILE_RECORD{  \n /*+0x00*/  FILE_RECORD_HEADER Ntfs;  // MFT表头  \n /*+0x10*/  uint16  SequenceNumber;   // 序列号(用于记录文件被反复使用的次数)  \n /*+0x12*/  uint16  LinkCount;        // 硬连接数  \n /*+0x14*/  uint16  AttributeOffset;  // 第一个属性偏移  \n /*+0x16*/  uint16  Flags;            // falgs, 00表示删除文件,01表示正常文件,02表示删除目录,03表示正常目录  \n /*+0x18*/  uint32  BytesInUse;       // 文件记录实时大小(字节) 当前MFT表项长度,到FFFFFF的长度+4  \n /*+0x1C*/  uint32  BytesAllocated;   // 文件记录分配大小(字节)  \n /*+0x20*/  uint64  BaseFileRecord;   // = 0 基础文件记录 File reference to the base FILE record  \n /*+0x28*/  uint16  NextAttributeNumber; // 下一个自由ID号  \n /*+0x2A*/  uint16  Pading;           // 边界  \n /*+0x2C*/  uint32  MFTRecordNumber;  // windows xp中使用,本MFT记录号  \n /*+0x30*/  uint32  MFTUseFlags;      // MFT的使用标记  \n}FILE_RECORD, *pFILE_RECORD;  \n</code></pre>\n<p class="line" data-line="220">根据FILE头部数据找到下面的一个个属性,接下来分析的就是一个个属性了，属性由属性头跟属性体组成,属性头的结构定义如下：</p>\n<pre class="hljs"><code class="hljs">// 属性头  \ntypedef struct  \n{  \n /*+0x00*/  ATTRIBUTE_TYPE AttributeType;    // 属性类型  \n /*+0x04*/  uint16 RecordLength;             // 总长度(Header+body长度)  \n /**0x06*/  uint16 unknow0;  \n /*+0x08*/  uchar Nonresident;               // 非常驻标志  \n /*+0x09*/  uchar NameLength;                // 操作属性名长度  \n  \n                                          // 0X0001为压缩标记  \n                                        // 0X4000为加密标记  \n                                        // 0X8000为系数文件标志  \n /*+0x0A*/  uint16 NameOffset;           // 属性名偏移(从属性起始位置的偏移)  \n                                              // NameLength 如果不为零,则用这个值去寻址数据偏移  \n /*+0x0C*/  uint16 Flags;                    // ATTRIBUTE_xxx flags.  \n /*+0x0E*/  uint16 AttributeNumber;          // The file-record-unique attribute instance number for this attribute.  \n} ATTRIBUTE, *PATTRIBUTE;  \n  \n// 属性头   \ntypedef struct _RESIDENT_ATTRIBUTE  \n{  \n /*+0x00*/  ATTRIBUTE Attribute;   // 属性  \n /*+0x10*/  uint32 ValueLength;    // Data部分长度  \n /*+0x14*/  uint16 ValueOffset;    // Data内容起始偏移  \n /*+0x16*/  uchar Flags;           // 索引标志  \n /*+0x17*/  uchar Padding0;        // 填充  \n} RESIDENT_ATTRIBUTE, *PRESIDENT_ATTRIBUTE;  \n</code></pre>\n<p class="line" data-line="252">Petya中涉及到MFT的属性</p>\n<pre class="hljs"><code class="hljs">// 属性类型定义 \nAttributeFileName = 0x30,  \nAttributeData = 0x80, \n</code></pre>\n<p class="line" data-line="259">这两个属性的定义如下：</p>\n<pre class="hljs"><code class="hljs">// 文件属性ATTRIBUTE\\.AttributeType == 0x30  \ntypedef struct  \n{  \n /*+0x00*/  uint64 DirectoryFile:48;    // 父目录记录号(前个字节)  \n /*+0x06*/  uint64 ReferenceNumber:16;  // +序列号(与目录相关)  \n /*+0x08*/  uint64 CreationTime;        // 文件创建时间  \n /*+0x10*/  uint64 ChangeTime;          // 文件修改时间          \n /*+0x18*/  uint64 LastWriteTime;       // MFT更新的时间  \n /*+0x20*/  uint64 LastAccessTime;      // 最后一次访问时间  \n /*+0x28*/  uint64 AllocatedSize;       // 文件分配大小  \n /*+0x30*/  uint64 DataSize;            // 文件实际大小  \n /*+0x38*/  uint32 FileAttributes;      // 标志,如目录压缩隐藏等  \n /*+0x3C*/  uint32 AlignmentOrReserved; // 用于EAS和重解析  \n /*+0x40*/  uchar NameLength;      // 以字符计的文件名长度,没字节占用字节数由下一字节命名空间确定  \n  \n            // 文件名命名空间, 0 POSIX大小写敏感,1 win32空间,2 DOS空间, 3 win32&DOS空间  \n /*+0x41*/  uchar NameType;          \n /*+0x42*/  wchar Name[1];         // 以Unicode方式标识的文件名  \n} FILENAME_ATTRIBUTE, *PFILENAME_ATTRIBUTE;  \n  \n// 数据流属性 ATTRIBUTE.AttributeType == 0x80   \ntypedef struct _NONRESIDENT_ATTRIBUTE  \n{  \n    /*+0x00*/   ATTRIBUTE Attribute;    \n  \n    /*+0x10*/   uint64 StartVcn;     // LowVcn 起始VCN  起始簇号  \n    /*+0x18*/   uint64 LastVcn;      // HighVcn  结束VCN  结束簇号  \n  \n    /*+0x20*/   uint16 RunArrayOffset;    // 数据运行的偏移，非常重要 \n    /*+0x22*/   uint16 CompressionUnit;   // 压缩引擎  \n    /*+0x24*/   uint32  Padding0;       // 填充  \n    /*+0x28*/   uint32  IndexedFlag;    // 为属性值分配大小(按分配的簇的字节数计算)  \n    /*+0x30*/   uint64 AllocatedSize;   // 属性值实际大小  \n    /*+0x38*/   uint64 DataSize;     // 属性值压缩大小  \n    /*+0x40*/   uint64 InitializedSize;   // 实际数据大小  \n    /*+0x48*/   uint64 CompressedSize;    // 压缩后大小  \n} NONRESIDENT_ATTRIBUTE, *PNONRESIDENT_ATTRIBUTE;  \n</code></pre>\n<ul>\n<li>对于0x30属性：</li>\n</ul>\n<p class="line" data-line="303">对于MFT中的0x30属性的直观认识，如下：</p>\n<p class="line" data-line="305">黄色部分对应着上表中的ATTRIBUTE结构，红色部分对应着上表中的NONRESIDENT_ATTRIBUTE结构。选中部分对应着FILENAME_ATTRIBUTE结构内容，这里面包含了文件的各种时间属性和文件名等内容。</p>\n<p class="text-center line" data-line="307"><img src="/uploads/2017/07/25/83f1f40efdf04df7bb760b0299c90b61.png" alt="" width="90%"></p>\n<p class="line" data-line="309">Petya病毒在遍历MFT时，会通过判断当前MFT的AttributeFileName属性判断是否加密该MFT。</p>\n<ul>\n<li>对于0x80属性：</li>\n</ul>\n<p class="line" data-line="313">对于MFT中的0x80属性的直观认识，如下：</p>\n<p class="line" data-line="315">黄色部分对应着上表中的ATTRIBUTE结构，红色部分对应着上表中的NONRESIDENT_ATTRIBUTE结构。绿色部分对应着RUN-LIST结构内容。</p>\n<p class="text-center line" data-line="317"><img src="/uploads/2017/07/25/0aa26858b723e9404715e63d982d3cf3.png" alt="" width="90%"></p>\n<p class="line" data-line="319">80H属性是文件数据属性，该属性容纳着文件的内容，文件的大小一般指的就是未命名数据流的大小。该属性没有最大最小限制，最小情况是该属性为常驻属性。常驻属性就不做多的解释了，如下是一个非常驻的80H属性。</p>\n<p class="line" data-line="321">该属性的“Run List”值为“32 0C 1B 00 00 0C”，其具体含义如下：</p>\n<p class="text-center line" data-line="323"><img src="/uploads/2017/07/25/11ec3809e86bab9c742003855fe4a065.png" alt="" width="90%"> </p>\n<p class="line" data-line="325">Petya病毒在加密文件内容时，会通过Run List定位到文件内容所在的真正扇区加密文件，如果文件内容大于2个扇区，则只加密前两个扇区。</p>\n<h2 class="line" data-line="327">恶意代码加载过程</h2>\n<h3 class="line" data-line="329">1 加载代码到0x8000执行</h3>\n<p class="line" data-line="331">从第一个扇区开始，读取0x20个扇区到0x8000地址处，随后跳到0x8000处执行</p>\n<p class="line" data-line="333">循环读取0x20个扇区代码片段：</p>\n<p class="text-center line" data-line="335"><img src="/uploads/2017/07/25/f1ddca4af289916c2eaa3b5fd527c52e.png" alt="" width="90%"> </p>\n<p class="line" data-line="337">在循环里使用int 13读取磁盘内容</p>\n<p class="text-center line" data-line="339"><img src="/uploads/2017/07/25/d517cab4208845fae0a933191f17768a.png" alt=""> </p>\n<h3 class="line" data-line="341">2 调用函数读取硬盘参数</h3>\n<p class="line" data-line="343">读取硬盘参数</p>\n<p class="text-center line" data-line="345"><img src="/uploads/2017/07/25/bc1e54d9ac8e7f62081cce176f621822.png" alt="" width="90%"> </p>\n<p class="line" data-line="347">比较“FA 31 C0 8E”硬编码，判断当前的第一个扇区的内容是不是病毒写入的内容。</p>\n<p class="text-center line" data-line="349"><img src="/uploads/2017/07/25/f989c9b49aca1fbef95fb2ed13ac55ca.png" alt="" width="90%"> </p>\n<h3 class="line" data-line="351">判断加密标志</h3>\n<p class="line" data-line="353">读取0x20扇区的内容（该扇区保存了病毒的配置信息），判断该扇区的第一个字节是不是1，如果是1，表示mbr已经被加过密，就来到显示勒索界面的流程;如果不为1，表示还未对MBR和MFT进行加密，进入加密流程。</p>\n<p class="text-center line" data-line="355"><img src="/uploads/2017/07/25/51d51b4c39e024fbb002d0a762828a41.png" alt="" width="99%"> </p>\n<h2 class="line" data-line="357">加密过程</h2>\n<h3 class="line" data-line="359">1 打印修复磁盘信息，设置加密标志</h3>\n<p class="line" data-line="361">打印出虚假的“Repairing file system on C:”信息，读取0x20扇区中的配置信息到内存，并将读取到的配置信息的加密标志设置为1。随后，将修改过加密标志的内容写入到扇区中，为了保证写入成功，这里循环写了0x20次。</p>\n<p class="line" data-line="363">打印的磁盘修复信息如下：</p>\n<p class="text-center line" data-line="365"><img src="/uploads/2017/07/25/fec6399d07d526a8fb688c8e4f54e1de.png" alt="" width="90%"> </p>\n<p class="text-center line" data-line="367"><img src="/uploads/2017/07/25/d514c1f5da08dc7fa6f656986c5a6564.png" alt="" width="90%"> </p>\n<h3 class="line" data-line="369">2 加密验证扇区</h3>\n<p class="line" data-line="371">加密验证扇区的方法为：读取0x21扇区的内容（这个扇区保存的全是0x07数据），使用从配置信息扇区读取的key与n做为加密参数，调用salsa加密该读到的0x07内容，并将加密后的内容写入到0x21扇区中</p>\n<p class="text-center line" data-line="373"><img src="/uploads/2017/07/25/5c0b22a8b5c23f1824f9da08267a83e0.png" alt="" width="90%"> </p>\n<p class="text-center line" data-line="375"><img src="/uploads/2017/07/25/099a8b6797c6401eabdb1efdd1b67b50.png" alt="" width="90%"> </p>\n<p class="line" data-line="377">显示虚假的“CHKDSK is repairing sector”界面，实际在后台正在加密MFT数据。</p>\n<p class="text-center line" data-line="379"><img src="/uploads/2017/07/25/9c27e3f0dcce5beaa74b5f250f5ca44d.png" alt="" width="90%"> </p>\n<h3 class="line" data-line="381">3 加密操作</h3>\n<h4 class="line" data-line="383">文件遍历的原理</h4>\n<p class="line" data-line="385">Petya病毒通过解析MBR，DBR得到MFT地址。解析MFT索引为0的元文件，得到属性为DATA的属性内容，取出属性中的RUN-LIST结构中的簇数量与起始扇区，根据这两个字段遍历所有的MFT就得到了当前文件系统中所有的文件信息。</p>\n<ol>\n<li>解析MBR</li>\n</ol>\n<p class="line" data-line="389">解析原始MBR数据的代码片段：</p>\n<p class="text-center line" data-line="391"><img src="/uploads/2017/07/25/c492c18191fb7333811c8d541a91f200.png" alt="" width="90%"> </p>\n<p class="line" data-line="393">判断MBR中的分区类型：</p>\n<p class="text-center line" data-line="395"><img src="/uploads/2017/07/25/84c682ad0195067b28cdd0b6f7f9a7f0.png" alt="" width="90%"> </p>\n<p class="line" data-line="397">判断从mbr中读取到的StartLBA字段不为空</p>\n<p class="text-center line" data-line="399"><img src="/uploads/2017/07/25/7d4060cd86c75d892c4f283b6f10ad1c.png" alt="" width="90%"> </p>\n<p class="line" data-line="401">从mbr中解析到StartLBA字段，并读取该字段对应的扇区，此扇区的内容就为DBR相关的内容：</p>\n<p class="text-center line" data-line="403"><img src="/uploads/2017/07/25/b423cd8965358de2784a89331806ba14.png" alt="" width="90%"> </p>\n<p class="line" data-line="405">读取到DBR后，解析出MftStartLcn字段，该字段就表示 MFT地址：</p>\n<p class="text-center line" data-line="407"><img src="/uploads/2017/07/25/9b006a175eec0a34093758e0ae23b111.png" alt="" width="90%"> </p>\n<p class="line" data-line="410">得到MFT地址后，该地址就是索引为0的MFT元文件地址,从该元文件结构中取出属性为0x80（DATA）的内容，</p>\n<p class="line" data-line="412">首先读取到$MFT的扇区内容：</p>\n<p class="text-center line" data-line="414"><img src="/uploads/2017/07/25/df5a5ee6c0ac0eba3a364436009c9a8a.png" alt="" width="90%"> </p>\n<p class="line" data-line="416">解析属性，判断是不是0x80(DATA)属性类型</p>\n<p class="text-center line" data-line="418"><img src="/uploads/2017/07/25/d8d49240c8840d7173ba6395017b4cef.png" alt="" width="90%"> </p>\n<p class="line" data-line="420">对$MFT属性0x80中的解析，得到下面信息：</p>\n<p class="line" data-line="422">run_data_cluster*sector/cluster + 0x20(0x20为元文件占用的扇区大小)+mbr. arg_StartLBA，作为普通 MFT扇区的起始扇区，这样是保证加密的过程中不会加密元文件扇区与mbr相关的扇区。</p>\n<p class="line" data-line="424">（run_data_num_clusters * sector/cluster）- 0x20(0x20为元文件占用的扇区大小)，做为普通MFT的扇区大小</p>\n<p class="text-center line" data-line="426"><img src="/uploads/2017/07/25/c8a6dc7b98daaf4b564a84671e995644.png" alt="" width="90%"> </p>\n<p class="line" data-line="428">随后，就来到遍历用户MFT的函数：</p>\n<p class="text-center line" data-line="430"><img src="/uploads/2017/07/25/a8b85a6edc3806c80fab3c03f24cde45.png" alt="" width="90%"> </p>\n<h4 class="line" data-line="433">遍历普通MFT结构</h4>\n<p class="line" data-line="435">遍历普通MFT结构的函数在00008FA6处，该函数为病毒代码中最为主要的函数。</p>\n<p class="line" data-line="437">下面对这个函数进行详细分析:</p>\n<p class="line" data-line="439">在调试的过程中，parse_User_MFT函数的参数内容为：80 C6 5F 00 60 00 20 C6  00 00 3F 00 00 00 3F 00 60 00 08 C6 2C 67 4A 67  8B 77 52 9C 01,结合调试时传递的参数内容，对函数作出说明。</p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>类型</th>\n<th>数据</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>dir_num</td>\n<td>WORD</td>\n<td>80 C6</td>\n<td>只取了第一字节80使用，在通过int 13读写扇区内容使用到</td>\n</tr>\n<tr>\n<td>abase_sector</td>\n<td>DWORD</td>\n<td>5F 00 60 00</td>\n<td>普通MFT的起始扇区</td>\n</tr>\n<tr>\n<td>TotalSetorNum</td>\n<td>WORD</td>\n<td>20 C6</td>\n<td>普通MFT扇区数量</td>\n</tr>\n<tr>\n<td>show_char</td>\n<td>WORD</td>\n<td>00 00</td>\n<td>用于屏幕显示</td>\n</tr>\n<tr>\n<td>StartLBA</td>\n<td>DWORD</td>\n<td>3F 00 00 00</td>\n<td>从mbr中解析出的startLBA字段，在加密过程中，如果MFT的数据内容在startLBA扇区内，就跳过到此扇区的加密，防止误把mbr重要数据加密</td>\n</tr>\n<tr>\n<td>arg_E</td>\n<td></td>\n<td>3F 00 60 00</td>\n<td>没使用</td>\n</tr>\n<tr>\n<td>SectorsPerCluster</td>\n<td>WORD</td>\n<td>08 C6</td>\n<td>只取了第一字节08使用，从dbr中解析出来的SectorsPerCluster字段，表示每簇的扇区数量</td>\n</tr>\n<tr>\n<td>p_encrypt_num</td>\n<td>WORD</td>\n<td>2C 67</td>\n<td>用来存放当前已经加密的扇区数量的缓冲区</td>\n</tr>\n<tr>\n<td>salsa_key</td>\n<td>WORD</td>\n<td>4A 67</td>\n<td>salsa算法使用的KEY</td>\n</tr>\n<tr>\n<td>arg_iv</td>\n<td>WORD</td>\n<td>8B 77</td>\n<td>salsa算法使用的 IV</td>\n</tr>\n<tr>\n<td>CharShow</td>\n<td>WORD</td>\n<td>52 9C</td>\n<td>用于显示界面字符</td>\n</tr>\n<tr>\n<td>arg_flag</td>\n<td>WORD</td>\n<td>01 00</td>\n<td>标志位，只是标志位为1时，才会加密</td>\n</tr>\n</tbody>\n</table>\n<p class="line" data-line="456">该函数主要功能为：对扇区中的MFT遍历，对不符合MFT头部标志(FILE)的扇区，会直接调用SALSA20算法进行加密该扇区，对符合MFT头部标志的扇区，判断0x30属性中的文件名判断是不是元文件，如果不是元文件名格式，则直接加密该扇区。其他情况下，判断MFT结构0x80属性中的常驻内存属性，如果是非常驻内存属性，就解析文件内容的前二个扇区，取出该扇区的内容后，使用salsa20算法进行加密。</p>\n<ol>\n<li>先打印出“CHKDSK is repairing sector”，显示虚假的磁盘修复界面</li>\n</ol>\n<p class="text-center line" data-line="460"><img src="/uploads/2017/07/25/a3977b49aeeb8e36a8332e627645cea8.png" alt="" width="90%"> </p>\n<ol start="2">\n<li>对当前MFT头是不是“FILE”,如果不是”FILE”的话，则直接加密这个扇区</li>\n</ol>\n<p class="text-center line" data-line="464"><img src="/uploads/2017/07/25/a4d9951bee67fcc18d8b0f8628c1096d.png" alt="" width="90%"> </p>\n<ol start="3">\n<li>如果是FILE，接着遍历mft的各个属性：</li>\n</ol>\n<p class="line" data-line="468">如果属性为AttributeFileName（0x30），判断文件名字长度是不是1，如果长度为1，直接加密，如果长度不为1，则看文件名字是不是以$开头(以$开头的是NTFS文件系统的元文件)，如果是元文件，则加密当前MFT.</p>\n<p class="text-center line" data-line="470"><img src="/uploads/2017/07/25/5ae904203b51d0c92e4885290661f3df.png" alt="" width="90%"> </p>\n<p class="line" data-line="472">如果属性为AttributeData文件数据属性（0x80），则首先根据属性头判断是不是非常驻内存，如果是常驻内存属性就跳过，不进行加密。如果是非常驻内存属性，则通过RUNLIST结构遍历到存储数据的真正的扇区位置。</p>\n<p class="text-center line" data-line="474"><img src="/uploads/2017/07/25/159054d773680803f830463365c03cfe.png" alt="" width="90%"> </p>\n<p class="line" data-line="476">解析RUNLIST</p>\n<p class="text-center line" data-line="478"><img src="/uploads/2017/07/25/6c00d5bf3e6c19a7b357c44d0fb3644f.png" alt="" width="90%"> </p>\n<p class="line" data-line="480">根据RUNLIST中的起始簇乘以MBR中保存的每簇对应的扇区数，得到数据真正所在的扇区。</p>\n<p class="text-center line" data-line="482"><img src="/uploads/2017/07/25/4eada2539c1ad8192fba15a8dd2e16d9.png" alt="" width="90%"> </p>\n<p class="line" data-line="484">随后，判断上面计算出的文件内容对应扇区数量是不是大于2，如果大于2，只加密前2个扇区。</p>\n<p class="text-center line" data-line="486"><img src="/uploads/2017/07/25/56b174bbd4c6ebd2af741ba73260282f.png" alt="" width="90%"> </p>\n<p class="line" data-line="488">读取该MFT文件对应的文件内容的前两个分区，通过直接使用int 13中断从扇区读取到文件内容，使用salsa20加密后，将密文直接写入的扇区中文件中。</p>\n<p class="text-center line" data-line="490"><img src="/uploads/2017/07/25/21f61a8ad162b6b73788d7af063ac414.png" alt="" width="90%"> </p>\n<p class="line" data-line="492">在动态调试时，可以看到加密了文件内容，加密文件内容前的数据</p>\n<p class="text-center line" data-line="494"><img src="/uploads/2017/07/25/8bd29bd4aaf54f20469012557b8ead84.png" alt="" width="90%"> </p>\n<p class="line" data-line="496">被加密后的文件内容：</p>\n<p class="text-center line" data-line="498"><img src="/uploads/2017/07/25/15be20fa0ee6c89862caf40abd228189.png" alt="" width="90%"> </p>\n<h4 class="line" data-line="500">加密函数</h4>\n<p class="line" data-line="502">对文件的加密使用了SALSA20算法，该算法属于流加密，在知道key和iv的情况下，加密函数和解密函数可以为相同的函数代码。</p>\n<p class="line" data-line="504">加密函数</p>\n<p class="text-center line" data-line="506"><img src="/uploads/2017/07/25/d891c0f3a128dfdca4ab9349aa61ea23.png" alt="" width="90%"> </p>\n<p class="line" data-line="508">在密钥扩展的函数中，Petya将原始的常数“expand 16-byte k”更改成了“1nvald s3ct”</p>\n<p class="line" data-line="510">扩展密钥函数代码：</p>\n<p class="text-center line" data-line="512"><img src="/uploads/2017/07/25/7513b898e9fe11f17806a9bc0614ba1a.png" alt="" width="90%"> </p>\n<p class="line" data-line="514">Salsa20加密时使用的key和iv来自于配置信息扇区（0x20扇区）</p>\n<p class="text-center line" data-line="516"><img src="/uploads/2017/07/25/10f91c1a321dc37c419c4c5a1261c93c.png" alt="" width="90%"> </p>\n<p class="line" data-line="518">将明文与生成的keystream异或，实现加密</p>\n<p class="text-center line" data-line="520"><img src="/uploads/2017/07/25/ffa6ee8604e5c1f1e5edc53e34aaedf9.png" alt="" width="90%"> </p>\n<h2 class="line" data-line="522">解密过程</h2>\n<p class="line" data-line="524">在开机启动过程中，MBR引导后，加载扇区中的恶意代码后，恶意代码会判断配置信息第1个BYTE是不是1，1表示已经加密过，则进入相应的解密过程中</p>\n<h3 class="line" data-line="526">1 打印勒索信息</h3>\n<p class="line" data-line="528">打印出勒索信息</p>\n<p class="text-center line" data-line="530"><img src="/uploads/2017/07/25/11d9442b024acdf131fa400c6998621f.png" alt="" width="90%"> </p>\n<p class="line" data-line="532">也就是显示如下的内容</p>\n<p class="text-center line" data-line="534"><img src="/uploads/2017/07/25/2d538d7d1f8876cdf572e1a7f49ba437.png" alt="" width="90%"> </p>\n<h3 class="line" data-line="536">2 读取用户输入的key</h3>\n<p class="line" data-line="538">清空内存，读取用户输入的key</p>\n<p class="text-center line" data-line="540"><img src="/uploads/2017/07/25/48e5dec1ad001bd80cea9e9a7c964cff.png" alt="" width="90%"> </p>\n<h3 class="line" data-line="542">3 验证用户的key</h3>\n<p class="line" data-line="544">在验证KEY的过程中，首先比较输入的key的长度，必须大于0x20长度</p>\n<p class="text-center line" data-line="546"><img src="/uploads/2017/07/25/ee5cc109d25593ee2c716d4f3e249d10.png" alt="" width="90%"> </p>\n<p class="line" data-line="548">将输入的key通过自定义算法的转换\t0x21次</p>\n<p class="text-center line" data-line="550"><img src="/uploads/2017/07/25/fb925063f3e363646b5ea38a27906542.png" alt="" width="90%"> </p>\n<p class="line" data-line="552">使用转换过的key，使用salsa20算法解密0x21扇区的内容（这个扇区的内容为加密过的0x7内容），比较解密出来的内容是不是0x7，如果是则表明解密密码正确。</p>\n<p class="text-center line" data-line="554"><img src="/uploads/2017/07/25/edd5fa6f10c48cb40a0b1180dce7091b.png" alt="" width="90%"> </p>\n<p class="text-center line" data-line="556"><img src="/uploads/2017/07/25/59681650ad38f20124784eb166f401a7.png" alt="" width="90%"> </p>\n<p class="line" data-line="558">密码验证通过后，会使用这个key做为参数调用DecryptProc 函数(并非勒索软件作者定义的函数名)，</p>\n<p class="text-center line" data-line="560"><img src="/uploads/2017/07/25/dcd446cbfc5100c94540914a8678b920.png" alt="" width="90%"> </p>\n<p class="line" data-line="562">在DecryptProc函数中调用与加密时相同的函数进行对MFT结构进行遍历后解密，</p>\n<p class="text-center line" data-line="564"><img src="/uploads/2017/07/25/7e511a9d53033224983402b4f516a926.png" alt="" width="90%"> </p>\n<p class="line" data-line="566">在解密完成后，打印“Please reboot your computer!”信息</p>\n<p class="text-center line" data-line="568"><img src="/uploads/2017/07/25/dcc15ec5f0d71412c6c3a571997689d6.png" alt="" width="90%"> </p>\n<h2 class="line" data-line="570">总结</h2>\n<p class="line" data-line="572">本文对Petya变种勒索蠕虫的扇区启动代码进行了详细分析，分析显示Petya变种勒索蠕虫并不仅会加密MBR和MFT结构，也会将MFT对应的文件内容的前两个扇区进行加密。换句话说，Petya变种勒索蠕虫在系统启动时MBR中的代码执行时也会进行全盘文件的加密操作。结合RING3级别的勒索代码功能，Petya会对文件执行两次加密操作，第一次为Petya勒索蠕虫执行时，使用RSA与AES算法遍历文件系统对指定扩展名的文件加密，第二次为系统启动时，启动扇区的代码会通过遍历MFT结构定位文件内容并对文件使用salsa20算法进行加密。对于RING3级别的文件加密过程，解密密钥可以通过勒索蠕虫作者的RSA私钥进行解密获得，而启动扇区级别的文件加密过程使用了随机密码进行，启动扇区级别的文件加密无法解密。</p>\n<h2 class="line" data-line="574">参考</h2>\n<p class="line" data-line="576"><a href="http://dengqi.blog.51cto.com/5685776/1351300">http://dengqi.blog.51cto.com/5685776/1351300</a></p>\n<p class="line" data-line="578"><a href="https://github.com/alexwebr/salsa20/blob/master/salsa20.c">https://github.com/alexwebr/salsa20/blob/master/salsa20.c</a></p>\n<p class="line" data-line="580"><a href="http://blog.csdn.net/enjoy5512/article/details/50966009">http://blog.csdn.net/enjoy5512/article/details/50966009</a></p>\n<p class="line" data-line="582"><a href="http://bobao.360.cn/learning/detail/4039.html">http://bobao.360.cn/learning/detail/4039.html</a></p>\n'}}],error:null,state:{pageId:[],tagParam:[],isMainPage:!1,pageNum:[1,2],articleData:{_id:"597733a71c670a09e493ee40",title:"Petya变种勒索蠕虫启动代码分析",category:"事件追踪",readableId:"analysis-of-petya-boot-code",abstract:"继5月的WannaCry勒索蠕虫事件以后，2017年6月又出现了Petya变种勒索蠕虫，除了利用永恒之蓝漏洞和加密勒索以后，Petya变种与WannaCry有比较大的差别。WannaCry会加密机器上的文件，导致数据损毁，而Petya更为激进，它会加密系统的MBR直接导致机器无法启动，本文对其执行的MBR及文件系统的加密机制做详细的分析。",author:"马茂刚",headImg:"/uploads/2017/08/17/6f753d60b82a62ef66be632f502646cc.png",descImg:"/uploads/2017/07/30/5abbf430bedd308ef9d6ff5623ee2961.png",tags:["mbr","petya"],publish_time:"2017-07-27T11:30:08.281Z",content:'<h1 class="line" data-line="0">背景</h1>\n<p class="line" data-line="2">继5月的WannaCry勒索蠕虫事件以后，2017年6月又出现了Petya变种勒索蠕虫，除了利用永恒之蓝漏洞和加密勒索以后，Petya变种与WannaCry有比较大的差别。WannaCry会加密机器上的文件，导致数据损毁，而Petya更为激进，它会加密系统的MBR直接导致机器无法启动，本文对其执行的MBR及文件系统的加密机制做详细的分析。</p>\n<h1 class="line" data-line="4">恶意代码分析</h1>\n<p class="line" data-line="6">由于执行恶意操作的指令并不是以文件形式存在，我们使用WinHex工具提取受攻击机器的磁盘前23个扇区的数据进行分析，对应代码数据的Hash为 841e12729f200a5620859f2958e2d484。</p>\n<h2 class="line" data-line="8">相关数据结构</h2>\n<p class="line" data-line="10">计算机启动时执行完BIOS的启动代码，检查各硬件设备正常后，JMP到MBR的引导代码进行执行；然后由MBR引导至活动分区的DBR，再由DBR引导操作系统。如：DBR调用NTLDR，再由NTLDR调用系统内核。</p>\n<p class="line" data-line="12">Petya病毒修改了系统的MBR，病毒在Bios加载后获得执行机会，病毒将加载存储在0x1扇区后的大小为0x20大小的病毒代码加载执行，这些代码会还原出真实的MBR，通过对还原出来的MBR解析，得到系统的DBR，通过DBR解析到系统的MFT结构，遍历所有的MFT，根据MFT找到文件内容所在的扇区后，读取该扇区加密内容后再写回到扇区中，从而实现对文件的加密。要完整的了解整个的加密过程，首先就是熟悉系统的MBR、DBR、MFT等结构的含义与功能。</p>\n<h3 class="line" data-line="14">MBR</h3>\n<p class="line" data-line="16">Petya病毒修改了系统的MBR，病毒在Bios加载后获得执行机会，病毒将加载存储在0x1扇区后的大小为0x20大小的病毒代码加载执行，这些代码会还原出真实的MBR。在加密文件的过程中，Petya病毒会使用到MBR中</p>\n<p class="line" data-line="18">MBR扇区由以下四部分组成：</p>\n<ul>\n<li>引导代码：引导代码占MBR分区的前440字节，负责整个系统启动。如果引导代码被破坏，系统将无法启动。</li>\n<li>Windows磁盘签名：占引导代码后面的4字节，是Windows初始化磁盘写入的磁盘标签，如果此标签被破坏，则系统会提示“初始化磁盘”。</li>\n<li>MBR分区表：占Windows磁盘标签后面的64个字节，是整个硬盘的分区表。</li>\n<li>MBR结束标志：占MBR扇区最后2个字节，一直为“55 AA”。</li>\n</ul>\n<p class="line" data-line="25">MBR结构如下：</p>\n<pre class="hljs"><code class="hljs">;====================================================================\n    主引导记录(MBR)结构\n;====================================================================\n typedef struct _MASTER_BOOT_RECORD\n {\n  UCHAR    BootCode[446];\n  PARTITION_ENTRY  Partition[4];\n  USHORT    Signature;\n }MASTER_BOOT_RECORD,*PMASTER_BOOT_RECORD;\n \n;====================================================================\n;====================================================================\n     分区表项结构(16字节)\n;====================================================================\n \n typedef struct _PARTITION_ENTRY\n {\n  UCHAR BootIndicator;  // 能否启动标志\n  UCHAR StartHead;   // 该分区起始磁头号\n  UCHAR StartSector;  // 起始柱面号高2位：6位起始扇区号\n  UCHAR StartCylinder;  // 起始柱面号低8位\n  UCHAR PartitionType;  // 分区类型\n  UCHAR EndHead;   // 该分区终止磁头号\n  UCHAR EndSector;   // 终止柱面号高2位：6位终止扇区号\n  UCHAR EndCylinder;  // 终止柱面号低8位\n  ULONG StartLBA;   // 起始扇区号\n  ULONG TotalSector;  // 分区尺寸（总扇区数）\n }PARTITION_ENTRY,*PPARTITION_ENTRY;\n</code></pre>\n<p class="line" data-line="58">对于其中的PartitionType 字段，Windows下可识别的分区类型主要有：</p>\n<ul>\n<li>0x07 表示普通分区(Windows分区、数据分区。默认分区类型)。</li>\n<li>0xEE 表示该分区表是PMBR，紧随其后的应该是GPT分区表头和GPT分区表，因此这是一块GPT硬盘。</li>\n<li>0xEF 表示EFI系统分区</li>\n</ul>\n<p class="line" data-line="64">Petya在解密出原始的MBR后，解析MBR结构，得到起始扇区号，并根据起始扇区定位到DBR。</p>\n<p class="line" data-line="66">病毒解析MBR时，会对分区类型做判断，如果PMBR和EFI类型的系统分区，默认会不做处理。</p>\n<p class="line" data-line="68">在010edit工具中查看</p>\n<p class="text-center line" data-line="70"><img src="/uploads/2017/07/25/cb8ab7085ca7da88a58ab5c86cc1e39c.png" alt="" width="90%"></p>\n<p class="line" data-line="72">判断分区类型，取了这两个字段：开始扇区与扇区大小：</p>\n<p class="text-center line" data-line="74"><img src="/uploads/2017/07/25/5bb7e2b71f9cd2a909737c77f19e5e48.png" alt="" width="90%"></p>\n<p class="line" data-line="76">在启动扇区（也就是63扇区）处，读一个扇区的内容，就是DBR结构</p>\n<p class="line" data-line="78">从MBR中可以定位到MBR分区表,根据分区表的属性就可以得到活动分区的扇区地址，也就得到了DBR结构地址。</p>\n<h3 class="line" data-line="80">DBR</h3>\n<p class="line" data-line="82">DBR中存放着关于文件系统的重要参数信息以及系统引导代码。病毒解析到DBR后，只是为了取的DBR结构中的MftStartLcn字段(这个字段表明了MFT结构所在的扇区地址)，以便能进一步定位文件系统。</p>\n<p class="line" data-line="84">DBR的结构如下：</p>\n<pre class="hljs"><code class="hljs"> ////////////////////////////////////////////////////////////////////////////  \n //  \n //  NTFS 的DBR 数据结构  \n //  \n ////////////////////////////////////////////////////////////////////////////  \n __typedef__ __struct__ _BIOS_PARAMETER_BLOCK {  \n   \n  /*+0x0B*/    uint16  BytesPerSector;    // 字节/扇区一般为0x0200 即512  \n  /*+0x0D*/    uchar   SectorsPerCluster; // 扇区/簇   \n  /*+0x0E*/    uint16  ReservedSectors;   // 保留扇区  \n  /*+0x0F*/    uchar   Fats;              //   \n  /*+0x11*/    uint16  RootEntries;       //   \n  /*+0x13*/    uint16  Sectors;           //   \n  /*+0x15*/    uchar   Media;             // 媒介描述  \n  /*+0x16*/    uint16  SectorsPerFat;     //   \n  /*+0x18*/    uint16  SectorsPerTrack;   // 扇区/磁轨  \n  /*+0x1A*/    uint16  Heads;             // 头  \n  /*+0x1C*/    uint32  HiddenSectors;     // 隐藏扇区  \n  /*+0x20*/    uint32  LargeSectors;      // checked when volume is mounted  \n   \n }BIOS_PARAMETER_BLOCK, *pBIOS_PARAMETER_BLOCK;  \n\n__typedef__ __struct__ _NTFS_Boot_Sector{  \n\n  /*+0x00*/  uchar    JmpCode[3];        // 跳转指令  \n  /*+0x03*/  __char__     OemID[8];          // 文件系统ID  \n  /*+0x0B*/  BIOS_PARAMETER_BLOCK PackedBpb;   // BPB  \n  /*+0x24*/  uchar    Unused[4];           // 未使用,总是为  \n  /*+0x28*/  uint64   NumberSectors;       // 扇区总数  \n  /*+0x30*/  lcn      MftStartLcn;        // 开始C# $MFT  (簇) 乘以 BIOS_PARAMETER_BLOCK.SectorsPerCluster 值得到扇区号  \n  /*+0x38*/  lcn      Mft2StartLcn;       // 开始C# $MFTMirr (簇)  \n  /*+0x40*/  uchar    ClustersPerFileRecordSegment;  // 文件记录大小指示器  \n  /*+0x41*/  uchar   Reserved0[3];       // 未使用  \n  /*+0x44*/  uchar DefaultClustersPerIndexAllocationBuffer;     // 簇/索引块  \n  /*+0x45*/  uchar   Reserved1[3];       // 未使用  \n  /*+0x48*/  uint64  SerialNumber;       // 64位序列号  \n  /*+0x50*/  uint32  Checksum;           // 校验和  \n  /*+0x54*/  uchar   BootStrap[426];     // 启动代码  \n  /*+0x1FE*/ uint16  RecordEndSign;      // 0xAA55 结束标记  \n }NTFS_Boot_Sector, *pNTFS_Boot_Sector;  \n</code></pre>\n<p class="line" data-line="129">其中，定位MFT时，最重要的结构为MftStartLcn表示起始簇号，乘以BIOS_PARAMETER_BLOCK.SectorsPerCluster（在我的机器上这个值为8，表示一个簇由8个扇区组成）后就得到起始扇区号。</p>\n<h3 class="line" data-line="131">MFT</h3>\n<h4 class="line" data-line="133">简介</h4>\n<p class="line" data-line="135">MFT，即主文件表（Master File Table）的简称，它是NTFS文件系统的核心。MFT由一个个MFT项（也称为文件记录）组成。每个MFT项的前部为0x10字节的头结构，用来描述本MFT项的相关信息。后面节存放着属性。每个文件和目录的信息都包含在MFT中，每个文件和目录至少有一个MFT项。除了引导扇区外，访问其他任何一个文件前都需要先访问MFT，在MFT中找到该文件的MFT项，根据MFT项中记录的信息找到文件内容并对其进行访问。</p>\n<p class="line" data-line="137">MFT结构分为两种：元文件与普通文件。</p>\n<p class="line" data-line="139">元文件对于用户是不能直接访问的，MFT将开头的16个文件记录块保留用于这些元数据文件，除此之外的文件记录块才用于普通的用户文件和目录。</p>\n<pre class="hljs"><code class="hljs">#### 16个元文件\n#define\tMFT_IDX_MFT\t\t\t\t0\n#define\tMFT_IDX_MFT_MIRR\t\t1\n#define\tMFT_IDX_LOG_FILE\t\t2\n#define\tMFT_IDX_VOLUME\t\t\t3\n#define\tMFT_IDX_ATTR_DEF\t\t4\n#define\tMFT_IDX_ROOT\t\t\t5\n#define\tMFT_IDX_BITMAP\t\t\t6\n#define\tMFT_IDX_BOOT\t\t\t7\n#define\tMFT_IDX_BAD_CLUSTER\t\t8\n#define\tMFT_IDX_SECURE\t\t\t9\n#define\tMFT_IDX_UPCASE\t\t\t10\n#define\tMFT_IDX_EXTEND\t\t\t11\n#define\tMFT_IDX_RESERVED12\t\t12\n#define\tMFT_IDX_RESERVED13\t\t13\n#define\tMFT_IDX_RESERVED14\t\t14\n#define\tMFT_IDX_RESERVED15\t\t15\n#define\tMFT_IDX_USER\t\t\t16\n</code></pre>\n<p class="line" data-line="162">这16个原文件本身也是MFT结构的模式，可以理解为记录了MFT信息的MFT结构。</p>\n<ul>\n<li>\n<p>怎么解析这16个原文件的MFT结构呢？</p>\n<ul>\n<li>换句话说，通过MBR定位到DBR,通过DBR定位到MFT，此时的MFT就对应着索引为MFT_IDX_MFT的MFT，向后偏移文件记录大小的地方，就存放着索引为MFT_IDX_MFT_MIRR的MFT。再向后偏移文件记录大小的地方，就存放着索引为MFT_IDX_LOG_FILE的MFT</li>\n</ul>\n</li>\n<li>\n<p>解析这16个原文件的MFT结构有什么用？</p>\n<ul>\n<li>如对于MFT_IDX_VOLUME 这个MFT结构，解析这个MFT结构中的ATTR_TYPE_VOLUME_INFORMATION（对应着0x70）就可以得到NTFS卷的版本信息,解析这个MFT结构中的ATTR_TYPE_VOLUME_NAME属性（对应着0x60）就可以得到NTFS卷名信息。</li>\n</ul>\n</li>\n</ul>\n<p class="line" data-line="170">再如，对于MFT_IDX_MFT 这个MFT结构，解析这个MFT结构中的ATTR_TYPE_DATA（对应0x80）的属性RealSize，就表示整个卷所有的文件记录的大小信息。利用这个大小信息是以字节表示的，用这个大小信息除以每个文件记录所占用的字节就得到了卷占有的文件记录数量。计算出来的文件记录数量是将元文件也计算在内的。</p>\n<p class="line" data-line="172">依次遍历每个文件记录数量，读取这个文件记录的内容就是MFT结构，解析这个MFT的对应属性就可以解析出文件名、文件属性、文件内容等。</p>\n<h4 class="line" data-line="174">普通MFT</h4>\n<p class="line" data-line="176">遍历文件时，从第16个文件记录开始向后遍历，才会得到普通的用户文件和目录信息及内容。</p>\n<h4 class="line" data-line="178">数据结构</h4>\n<p class="line" data-line="180">MFT的直观结构如下，</p>\n<pre class="hljs"><code class="hljs">// 文件记录体\n// 属性1\n// 属性2\n// …………\n</code></pre>\n<p class="text-center line" data-line="189"><img src="/uploads/2017/07/25/305f756feed25724d4e439b3ab6bd804.png" alt="" width="75%"></p>\n<p class="line" data-line="191">每个MFT的结构如下：</p>\n<pre class="hljs"><code class="hljs">// 文件记录头  \ntypedef struct _FILE_RECORD_HEADER  \n{  \n /*+0x00*/  uint32 Type;            // 固定值\'FILE\'  \n /*+0x04*/  uint16 UsaOffset;       // 更新序列号偏移, 与操作系统有关  \n /*+0x06*/  uint16 UsaCount;        // 固定列表大小Size in words of Update Sequence Number & Array (S)  \n /*+0x08*/  uint64 Lsn;             // 日志文件序列号(LSN)  \n} FILE_RECORD_HEADER, *PFILE_RECORD_HEADER;  \n  \n// 文件记录体  \ntypedef struct _FILE_RECORD{  \n /*+0x00*/  FILE_RECORD_HEADER Ntfs;  // MFT表头  \n /*+0x10*/  uint16  SequenceNumber;   // 序列号(用于记录文件被反复使用的次数)  \n /*+0x12*/  uint16  LinkCount;        // 硬连接数  \n /*+0x14*/  uint16  AttributeOffset;  // 第一个属性偏移  \n /*+0x16*/  uint16  Flags;            // falgs, 00表示删除文件,01表示正常文件,02表示删除目录,03表示正常目录  \n /*+0x18*/  uint32  BytesInUse;       // 文件记录实时大小(字节) 当前MFT表项长度,到FFFFFF的长度+4  \n /*+0x1C*/  uint32  BytesAllocated;   // 文件记录分配大小(字节)  \n /*+0x20*/  uint64  BaseFileRecord;   // = 0 基础文件记录 File reference to the base FILE record  \n /*+0x28*/  uint16  NextAttributeNumber; // 下一个自由ID号  \n /*+0x2A*/  uint16  Pading;           // 边界  \n /*+0x2C*/  uint32  MFTRecordNumber;  // windows xp中使用,本MFT记录号  \n /*+0x30*/  uint32  MFTUseFlags;      // MFT的使用标记  \n}FILE_RECORD, *pFILE_RECORD;  \n</code></pre>\n<p class="line" data-line="220">根据FILE头部数据找到下面的一个个属性,接下来分析的就是一个个属性了，属性由属性头跟属性体组成,属性头的结构定义如下：</p>\n<pre class="hljs"><code class="hljs">// 属性头  \ntypedef struct  \n{  \n /*+0x00*/  ATTRIBUTE_TYPE AttributeType;    // 属性类型  \n /*+0x04*/  uint16 RecordLength;             // 总长度(Header+body长度)  \n /**0x06*/  uint16 unknow0;  \n /*+0x08*/  uchar Nonresident;               // 非常驻标志  \n /*+0x09*/  uchar NameLength;                // 操作属性名长度  \n  \n                                          // 0X0001为压缩标记  \n                                        // 0X4000为加密标记  \n                                        // 0X8000为系数文件标志  \n /*+0x0A*/  uint16 NameOffset;           // 属性名偏移(从属性起始位置的偏移)  \n                                              // NameLength 如果不为零,则用这个值去寻址数据偏移  \n /*+0x0C*/  uint16 Flags;                    // ATTRIBUTE_xxx flags.  \n /*+0x0E*/  uint16 AttributeNumber;          // The file-record-unique attribute instance number for this attribute.  \n} ATTRIBUTE, *PATTRIBUTE;  \n  \n// 属性头   \ntypedef struct _RESIDENT_ATTRIBUTE  \n{  \n /*+0x00*/  ATTRIBUTE Attribute;   // 属性  \n /*+0x10*/  uint32 ValueLength;    // Data部分长度  \n /*+0x14*/  uint16 ValueOffset;    // Data内容起始偏移  \n /*+0x16*/  uchar Flags;           // 索引标志  \n /*+0x17*/  uchar Padding0;        // 填充  \n} RESIDENT_ATTRIBUTE, *PRESIDENT_ATTRIBUTE;  \n</code></pre>\n<p class="line" data-line="252">Petya中涉及到MFT的属性</p>\n<pre class="hljs"><code class="hljs">// 属性类型定义 \nAttributeFileName = 0x30,  \nAttributeData = 0x80, \n</code></pre>\n<p class="line" data-line="259">这两个属性的定义如下：</p>\n<pre class="hljs"><code class="hljs">// 文件属性ATTRIBUTE\\.AttributeType == 0x30  \ntypedef struct  \n{  \n /*+0x00*/  uint64 DirectoryFile:48;    // 父目录记录号(前个字节)  \n /*+0x06*/  uint64 ReferenceNumber:16;  // +序列号(与目录相关)  \n /*+0x08*/  uint64 CreationTime;        // 文件创建时间  \n /*+0x10*/  uint64 ChangeTime;          // 文件修改时间          \n /*+0x18*/  uint64 LastWriteTime;       // MFT更新的时间  \n /*+0x20*/  uint64 LastAccessTime;      // 最后一次访问时间  \n /*+0x28*/  uint64 AllocatedSize;       // 文件分配大小  \n /*+0x30*/  uint64 DataSize;            // 文件实际大小  \n /*+0x38*/  uint32 FileAttributes;      // 标志,如目录压缩隐藏等  \n /*+0x3C*/  uint32 AlignmentOrReserved; // 用于EAS和重解析  \n /*+0x40*/  uchar NameLength;      // 以字符计的文件名长度,没字节占用字节数由下一字节命名空间确定  \n  \n            // 文件名命名空间, 0 POSIX大小写敏感,1 win32空间,2 DOS空间, 3 win32&DOS空间  \n /*+0x41*/  uchar NameType;          \n /*+0x42*/  wchar Name[1];         // 以Unicode方式标识的文件名  \n} FILENAME_ATTRIBUTE, *PFILENAME_ATTRIBUTE;  \n  \n// 数据流属性 ATTRIBUTE.AttributeType == 0x80   \ntypedef struct _NONRESIDENT_ATTRIBUTE  \n{  \n    /*+0x00*/   ATTRIBUTE Attribute;    \n  \n    /*+0x10*/   uint64 StartVcn;     // LowVcn 起始VCN  起始簇号  \n    /*+0x18*/   uint64 LastVcn;      // HighVcn  结束VCN  结束簇号  \n  \n    /*+0x20*/   uint16 RunArrayOffset;    // 数据运行的偏移，非常重要 \n    /*+0x22*/   uint16 CompressionUnit;   // 压缩引擎  \n    /*+0x24*/   uint32  Padding0;       // 填充  \n    /*+0x28*/   uint32  IndexedFlag;    // 为属性值分配大小(按分配的簇的字节数计算)  \n    /*+0x30*/   uint64 AllocatedSize;   // 属性值实际大小  \n    /*+0x38*/   uint64 DataSize;     // 属性值压缩大小  \n    /*+0x40*/   uint64 InitializedSize;   // 实际数据大小  \n    /*+0x48*/   uint64 CompressedSize;    // 压缩后大小  \n} NONRESIDENT_ATTRIBUTE, *PNONRESIDENT_ATTRIBUTE;  \n</code></pre>\n<ul>\n<li>对于0x30属性：</li>\n</ul>\n<p class="line" data-line="303">对于MFT中的0x30属性的直观认识，如下：</p>\n<p class="line" data-line="305">黄色部分对应着上表中的ATTRIBUTE结构，红色部分对应着上表中的NONRESIDENT_ATTRIBUTE结构。选中部分对应着FILENAME_ATTRIBUTE结构内容，这里面包含了文件的各种时间属性和文件名等内容。</p>\n<p class="text-center line" data-line="307"><img src="/uploads/2017/07/25/83f1f40efdf04df7bb760b0299c90b61.png" alt="" width="90%"></p>\n<p class="line" data-line="309">Petya病毒在遍历MFT时，会通过判断当前MFT的AttributeFileName属性判断是否加密该MFT。</p>\n<ul>\n<li>对于0x80属性：</li>\n</ul>\n<p class="line" data-line="313">对于MFT中的0x80属性的直观认识，如下：</p>\n<p class="line" data-line="315">黄色部分对应着上表中的ATTRIBUTE结构，红色部分对应着上表中的NONRESIDENT_ATTRIBUTE结构。绿色部分对应着RUN-LIST结构内容。</p>\n<p class="text-center line" data-line="317"><img src="/uploads/2017/07/25/0aa26858b723e9404715e63d982d3cf3.png" alt="" width="90%"></p>\n<p class="line" data-line="319">80H属性是文件数据属性，该属性容纳着文件的内容，文件的大小一般指的就是未命名数据流的大小。该属性没有最大最小限制，最小情况是该属性为常驻属性。常驻属性就不做多的解释了，如下是一个非常驻的80H属性。</p>\n<p class="line" data-line="321">该属性的“Run List”值为“32 0C 1B 00 00 0C”，其具体含义如下：</p>\n<p class="text-center line" data-line="323"><img src="/uploads/2017/07/25/11ec3809e86bab9c742003855fe4a065.png" alt="" width="90%"> </p>\n<p class="line" data-line="325">Petya病毒在加密文件内容时，会通过Run List定位到文件内容所在的真正扇区加密文件，如果文件内容大于2个扇区，则只加密前两个扇区。</p>\n<h2 class="line" data-line="327">恶意代码加载过程</h2>\n<h3 class="line" data-line="329">1 加载代码到0x8000执行</h3>\n<p class="line" data-line="331">从第一个扇区开始，读取0x20个扇区到0x8000地址处，随后跳到0x8000处执行</p>\n<p class="line" data-line="333">循环读取0x20个扇区代码片段：</p>\n<p class="text-center line" data-line="335"><img src="/uploads/2017/07/25/f1ddca4af289916c2eaa3b5fd527c52e.png" alt="" width="90%"> </p>\n<p class="line" data-line="337">在循环里使用int 13读取磁盘内容</p>\n<p class="text-center line" data-line="339"><img src="/uploads/2017/07/25/d517cab4208845fae0a933191f17768a.png" alt=""> </p>\n<h3 class="line" data-line="341">2 调用函数读取硬盘参数</h3>\n<p class="line" data-line="343">读取硬盘参数</p>\n<p class="text-center line" data-line="345"><img src="/uploads/2017/07/25/bc1e54d9ac8e7f62081cce176f621822.png" alt="" width="90%"> </p>\n<p class="line" data-line="347">比较“FA 31 C0 8E”硬编码，判断当前的第一个扇区的内容是不是病毒写入的内容。</p>\n<p class="text-center line" data-line="349"><img src="/uploads/2017/07/25/f989c9b49aca1fbef95fb2ed13ac55ca.png" alt="" width="90%"> </p>\n<h3 class="line" data-line="351">判断加密标志</h3>\n<p class="line" data-line="353">读取0x20扇区的内容（该扇区保存了病毒的配置信息），判断该扇区的第一个字节是不是1，如果是1，表示mbr已经被加过密，就来到显示勒索界面的流程;如果不为1，表示还未对MBR和MFT进行加密，进入加密流程。</p>\n<p class="text-center line" data-line="355"><img src="/uploads/2017/07/25/51d51b4c39e024fbb002d0a762828a41.png" alt="" width="99%"> </p>\n<h2 class="line" data-line="357">加密过程</h2>\n<h3 class="line" data-line="359">1 打印修复磁盘信息，设置加密标志</h3>\n<p class="line" data-line="361">打印出虚假的“Repairing file system on C:”信息，读取0x20扇区中的配置信息到内存，并将读取到的配置信息的加密标志设置为1。随后，将修改过加密标志的内容写入到扇区中，为了保证写入成功，这里循环写了0x20次。</p>\n<p class="line" data-line="363">打印的磁盘修复信息如下：</p>\n<p class="text-center line" data-line="365"><img src="/uploads/2017/07/25/fec6399d07d526a8fb688c8e4f54e1de.png" alt="" width="90%"> </p>\n<p class="text-center line" data-line="367"><img src="/uploads/2017/07/25/d514c1f5da08dc7fa6f656986c5a6564.png" alt="" width="90%"> </p>\n<h3 class="line" data-line="369">2 加密验证扇区</h3>\n<p class="line" data-line="371">加密验证扇区的方法为：读取0x21扇区的内容（这个扇区保存的全是0x07数据），使用从配置信息扇区读取的key与n做为加密参数，调用salsa加密该读到的0x07内容，并将加密后的内容写入到0x21扇区中</p>\n<p class="text-center line" data-line="373"><img src="/uploads/2017/07/25/5c0b22a8b5c23f1824f9da08267a83e0.png" alt="" width="90%"> </p>\n<p class="text-center line" data-line="375"><img src="/uploads/2017/07/25/099a8b6797c6401eabdb1efdd1b67b50.png" alt="" width="90%"> </p>\n<p class="line" data-line="377">显示虚假的“CHKDSK is repairing sector”界面，实际在后台正在加密MFT数据。</p>\n<p class="text-center line" data-line="379"><img src="/uploads/2017/07/25/9c27e3f0dcce5beaa74b5f250f5ca44d.png" alt="" width="90%"> </p>\n<h3 class="line" data-line="381">3 加密操作</h3>\n<h4 class="line" data-line="383">文件遍历的原理</h4>\n<p class="line" data-line="385">Petya病毒通过解析MBR，DBR得到MFT地址。解析MFT索引为0的元文件，得到属性为DATA的属性内容，取出属性中的RUN-LIST结构中的簇数量与起始扇区，根据这两个字段遍历所有的MFT就得到了当前文件系统中所有的文件信息。</p>\n<ol>\n<li>解析MBR</li>\n</ol>\n<p class="line" data-line="389">解析原始MBR数据的代码片段：</p>\n<p class="text-center line" data-line="391"><img src="/uploads/2017/07/25/c492c18191fb7333811c8d541a91f200.png" alt="" width="90%"> </p>\n<p class="line" data-line="393">判断MBR中的分区类型：</p>\n<p class="text-center line" data-line="395"><img src="/uploads/2017/07/25/84c682ad0195067b28cdd0b6f7f9a7f0.png" alt="" width="90%"> </p>\n<p class="line" data-line="397">判断从mbr中读取到的StartLBA字段不为空</p>\n<p class="text-center line" data-line="399"><img src="/uploads/2017/07/25/7d4060cd86c75d892c4f283b6f10ad1c.png" alt="" width="90%"> </p>\n<p class="line" data-line="401">从mbr中解析到StartLBA字段，并读取该字段对应的扇区，此扇区的内容就为DBR相关的内容：</p>\n<p class="text-center line" data-line="403"><img src="/uploads/2017/07/25/b423cd8965358de2784a89331806ba14.png" alt="" width="90%"> </p>\n<p class="line" data-line="405">读取到DBR后，解析出MftStartLcn字段，该字段就表示 MFT地址：</p>\n<p class="text-center line" data-line="407"><img src="/uploads/2017/07/25/9b006a175eec0a34093758e0ae23b111.png" alt="" width="90%"> </p>\n<p class="line" data-line="410">得到MFT地址后，该地址就是索引为0的MFT元文件地址,从该元文件结构中取出属性为0x80（DATA）的内容，</p>\n<p class="line" data-line="412">首先读取到$MFT的扇区内容：</p>\n<p class="text-center line" data-line="414"><img src="/uploads/2017/07/25/df5a5ee6c0ac0eba3a364436009c9a8a.png" alt="" width="90%"> </p>\n<p class="line" data-line="416">解析属性，判断是不是0x80(DATA)属性类型</p>\n<p class="text-center line" data-line="418"><img src="/uploads/2017/07/25/d8d49240c8840d7173ba6395017b4cef.png" alt="" width="90%"> </p>\n<p class="line" data-line="420">对$MFT属性0x80中的解析，得到下面信息：</p>\n<p class="line" data-line="422">run_data_cluster*sector/cluster + 0x20(0x20为元文件占用的扇区大小)+mbr. arg_StartLBA，作为普通 MFT扇区的起始扇区，这样是保证加密的过程中不会加密元文件扇区与mbr相关的扇区。</p>\n<p class="line" data-line="424">（run_data_num_clusters * sector/cluster）- 0x20(0x20为元文件占用的扇区大小)，做为普通MFT的扇区大小</p>\n<p class="text-center line" data-line="426"><img src="/uploads/2017/07/25/c8a6dc7b98daaf4b564a84671e995644.png" alt="" width="90%"> </p>\n<p class="line" data-line="428">随后，就来到遍历用户MFT的函数：</p>\n<p class="text-center line" data-line="430"><img src="/uploads/2017/07/25/a8b85a6edc3806c80fab3c03f24cde45.png" alt="" width="90%"> </p>\n<h4 class="line" data-line="433">遍历普通MFT结构</h4>\n<p class="line" data-line="435">遍历普通MFT结构的函数在00008FA6处，该函数为病毒代码中最为主要的函数。</p>\n<p class="line" data-line="437">下面对这个函数进行详细分析:</p>\n<p class="line" data-line="439">在调试的过程中，parse_User_MFT函数的参数内容为：80 C6 5F 00 60 00 20 C6  00 00 3F 00 00 00 3F 00 60 00 08 C6 2C 67 4A 67  8B 77 52 9C 01,结合调试时传递的参数内容，对函数作出说明。</p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>类型</th>\n<th>数据</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>dir_num</td>\n<td>WORD</td>\n<td>80 C6</td>\n<td>只取了第一字节80使用，在通过int 13读写扇区内容使用到</td>\n</tr>\n<tr>\n<td>abase_sector</td>\n<td>DWORD</td>\n<td>5F 00 60 00</td>\n<td>普通MFT的起始扇区</td>\n</tr>\n<tr>\n<td>TotalSetorNum</td>\n<td>WORD</td>\n<td>20 C6</td>\n<td>普通MFT扇区数量</td>\n</tr>\n<tr>\n<td>show_char</td>\n<td>WORD</td>\n<td>00 00</td>\n<td>用于屏幕显示</td>\n</tr>\n<tr>\n<td>StartLBA</td>\n<td>DWORD</td>\n<td>3F 00 00 00</td>\n<td>从mbr中解析出的startLBA字段，在加密过程中，如果MFT的数据内容在startLBA扇区内，就跳过到此扇区的加密，防止误把mbr重要数据加密</td>\n</tr>\n<tr>\n<td>arg_E</td>\n<td></td>\n<td>3F 00 60 00</td>\n<td>没使用</td>\n</tr>\n<tr>\n<td>SectorsPerCluster</td>\n<td>WORD</td>\n<td>08 C6</td>\n<td>只取了第一字节08使用，从dbr中解析出来的SectorsPerCluster字段，表示每簇的扇区数量</td>\n</tr>\n<tr>\n<td>p_encrypt_num</td>\n<td>WORD</td>\n<td>2C 67</td>\n<td>用来存放当前已经加密的扇区数量的缓冲区</td>\n</tr>\n<tr>\n<td>salsa_key</td>\n<td>WORD</td>\n<td>4A 67</td>\n<td>salsa算法使用的KEY</td>\n</tr>\n<tr>\n<td>arg_iv</td>\n<td>WORD</td>\n<td>8B 77</td>\n<td>salsa算法使用的 IV</td>\n</tr>\n<tr>\n<td>CharShow</td>\n<td>WORD</td>\n<td>52 9C</td>\n<td>用于显示界面字符</td>\n</tr>\n<tr>\n<td>arg_flag</td>\n<td>WORD</td>\n<td>01 00</td>\n<td>标志位，只是标志位为1时，才会加密</td>\n</tr>\n</tbody>\n</table>\n<p class="line" data-line="456">该函数主要功能为：对扇区中的MFT遍历，对不符合MFT头部标志(FILE)的扇区，会直接调用SALSA20算法进行加密该扇区，对符合MFT头部标志的扇区，判断0x30属性中的文件名判断是不是元文件，如果不是元文件名格式，则直接加密该扇区。其他情况下，判断MFT结构0x80属性中的常驻内存属性，如果是非常驻内存属性，就解析文件内容的前二个扇区，取出该扇区的内容后，使用salsa20算法进行加密。</p>\n<ol>\n<li>先打印出“CHKDSK is repairing sector”，显示虚假的磁盘修复界面</li>\n</ol>\n<p class="text-center line" data-line="460"><img src="/uploads/2017/07/25/a3977b49aeeb8e36a8332e627645cea8.png" alt="" width="90%"> </p>\n<ol start="2">\n<li>对当前MFT头是不是“FILE”,如果不是”FILE”的话，则直接加密这个扇区</li>\n</ol>\n<p class="text-center line" data-line="464"><img src="/uploads/2017/07/25/a4d9951bee67fcc18d8b0f8628c1096d.png" alt="" width="90%"> </p>\n<ol start="3">\n<li>如果是FILE，接着遍历mft的各个属性：</li>\n</ol>\n<p class="line" data-line="468">如果属性为AttributeFileName（0x30），判断文件名字长度是不是1，如果长度为1，直接加密，如果长度不为1，则看文件名字是不是以$开头(以$开头的是NTFS文件系统的元文件)，如果是元文件，则加密当前MFT.</p>\n<p class="text-center line" data-line="470"><img src="/uploads/2017/07/25/5ae904203b51d0c92e4885290661f3df.png" alt="" width="90%"> </p>\n<p class="line" data-line="472">如果属性为AttributeData文件数据属性（0x80），则首先根据属性头判断是不是非常驻内存，如果是常驻内存属性就跳过，不进行加密。如果是非常驻内存属性，则通过RUNLIST结构遍历到存储数据的真正的扇区位置。</p>\n<p class="text-center line" data-line="474"><img src="/uploads/2017/07/25/159054d773680803f830463365c03cfe.png" alt="" width="90%"> </p>\n<p class="line" data-line="476">解析RUNLIST</p>\n<p class="text-center line" data-line="478"><img src="/uploads/2017/07/25/6c00d5bf3e6c19a7b357c44d0fb3644f.png" alt="" width="90%"> </p>\n<p class="line" data-line="480">根据RUNLIST中的起始簇乘以MBR中保存的每簇对应的扇区数，得到数据真正所在的扇区。</p>\n<p class="text-center line" data-line="482"><img src="/uploads/2017/07/25/4eada2539c1ad8192fba15a8dd2e16d9.png" alt="" width="90%"> </p>\n<p class="line" data-line="484">随后，判断上面计算出的文件内容对应扇区数量是不是大于2，如果大于2，只加密前2个扇区。</p>\n<p class="text-center line" data-line="486"><img src="/uploads/2017/07/25/56b174bbd4c6ebd2af741ba73260282f.png" alt="" width="90%"> </p>\n<p class="line" data-line="488">读取该MFT文件对应的文件内容的前两个分区，通过直接使用int 13中断从扇区读取到文件内容，使用salsa20加密后，将密文直接写入的扇区中文件中。</p>\n<p class="text-center line" data-line="490"><img src="/uploads/2017/07/25/21f61a8ad162b6b73788d7af063ac414.png" alt="" width="90%"> </p>\n<p class="line" data-line="492">在动态调试时，可以看到加密了文件内容，加密文件内容前的数据</p>\n<p class="text-center line" data-line="494"><img src="/uploads/2017/07/25/8bd29bd4aaf54f20469012557b8ead84.png" alt="" width="90%"> </p>\n<p class="line" data-line="496">被加密后的文件内容：</p>\n<p class="text-center line" data-line="498"><img src="/uploads/2017/07/25/15be20fa0ee6c89862caf40abd228189.png" alt="" width="90%"> </p>\n<h4 class="line" data-line="500">加密函数</h4>\n<p class="line" data-line="502">对文件的加密使用了SALSA20算法，该算法属于流加密，在知道key和iv的情况下，加密函数和解密函数可以为相同的函数代码。</p>\n<p class="line" data-line="504">加密函数</p>\n<p class="text-center line" data-line="506"><img src="/uploads/2017/07/25/d891c0f3a128dfdca4ab9349aa61ea23.png" alt="" width="90%"> </p>\n<p class="line" data-line="508">在密钥扩展的函数中，Petya将原始的常数“expand 16-byte k”更改成了“1nvald s3ct”</p>\n<p class="line" data-line="510">扩展密钥函数代码：</p>\n<p class="text-center line" data-line="512"><img src="/uploads/2017/07/25/7513b898e9fe11f17806a9bc0614ba1a.png" alt="" width="90%"> </p>\n<p class="line" data-line="514">Salsa20加密时使用的key和iv来自于配置信息扇区（0x20扇区）</p>\n<p class="text-center line" data-line="516"><img src="/uploads/2017/07/25/10f91c1a321dc37c419c4c5a1261c93c.png" alt="" width="90%"> </p>\n<p class="line" data-line="518">将明文与生成的keystream异或，实现加密</p>\n<p class="text-center line" data-line="520"><img src="/uploads/2017/07/25/ffa6ee8604e5c1f1e5edc53e34aaedf9.png" alt="" width="90%"> </p>\n<h2 class="line" data-line="522">解密过程</h2>\n<p class="line" data-line="524">在开机启动过程中，MBR引导后，加载扇区中的恶意代码后，恶意代码会判断配置信息第1个BYTE是不是1，1表示已经加密过，则进入相应的解密过程中</p>\n<h3 class="line" data-line="526">1 打印勒索信息</h3>\n<p class="line" data-line="528">打印出勒索信息</p>\n<p class="text-center line" data-line="530"><img src="/uploads/2017/07/25/11d9442b024acdf131fa400c6998621f.png" alt="" width="90%"> </p>\n<p class="line" data-line="532">也就是显示如下的内容</p>\n<p class="text-center line" data-line="534"><img src="/uploads/2017/07/25/2d538d7d1f8876cdf572e1a7f49ba437.png" alt="" width="90%"> </p>\n<h3 class="line" data-line="536">2 读取用户输入的key</h3>\n<p class="line" data-line="538">清空内存，读取用户输入的key</p>\n<p class="text-center line" data-line="540"><img src="/uploads/2017/07/25/48e5dec1ad001bd80cea9e9a7c964cff.png" alt="" width="90%"> </p>\n<h3 class="line" data-line="542">3 验证用户的key</h3>\n<p class="line" data-line="544">在验证KEY的过程中，首先比较输入的key的长度，必须大于0x20长度</p>\n<p class="text-center line" data-line="546"><img src="/uploads/2017/07/25/ee5cc109d25593ee2c716d4f3e249d10.png" alt="" width="90%"> </p>\n<p class="line" data-line="548">将输入的key通过自定义算法的转换\t0x21次</p>\n<p class="text-center line" data-line="550"><img src="/uploads/2017/07/25/fb925063f3e363646b5ea38a27906542.png" alt="" width="90%"> </p>\n<p class="line" data-line="552">使用转换过的key，使用salsa20算法解密0x21扇区的内容（这个扇区的内容为加密过的0x7内容），比较解密出来的内容是不是0x7，如果是则表明解密密码正确。</p>\n<p class="text-center line" data-line="554"><img src="/uploads/2017/07/25/edd5fa6f10c48cb40a0b1180dce7091b.png" alt="" width="90%"> </p>\n<p class="text-center line" data-line="556"><img src="/uploads/2017/07/25/59681650ad38f20124784eb166f401a7.png" alt="" width="90%"> </p>\n<p class="line" data-line="558">密码验证通过后，会使用这个key做为参数调用DecryptProc 函数(并非勒索软件作者定义的函数名)，</p>\n<p class="text-center line" data-line="560"><img src="/uploads/2017/07/25/dcd446cbfc5100c94540914a8678b920.png" alt="" width="90%"> </p>\n<p class="line" data-line="562">在DecryptProc函数中调用与加密时相同的函数进行对MFT结构进行遍历后解密，</p>\n<p class="text-center line" data-line="564"><img src="/uploads/2017/07/25/7e511a9d53033224983402b4f516a926.png" alt="" width="90%"> </p>\n<p class="line" data-line="566">在解密完成后，打印“Please reboot your computer!”信息</p>\n<p class="text-center line" data-line="568"><img src="/uploads/2017/07/25/dcc15ec5f0d71412c6c3a571997689d6.png" alt="" width="90%"> </p>\n<h2 class="line" data-line="570">总结</h2>\n<p class="line" data-line="572">本文对Petya变种勒索蠕虫的扇区启动代码进行了详细分析，分析显示Petya变种勒索蠕虫并不仅会加密MBR和MFT结构，也会将MFT对应的文件内容的前两个扇区进行加密。换句话说，Petya变种勒索蠕虫在系统启动时MBR中的代码执行时也会进行全盘文件的加密操作。结合RING3级别的勒索代码功能，Petya会对文件执行两次加密操作，第一次为Petya勒索蠕虫执行时，使用RSA与AES算法遍历文件系统对指定扩展名的文件加密，第二次为系统启动时，启动扇区的代码会通过遍历MFT结构定位文件内容并对文件使用salsa20算法进行加密。对于RING3级别的文件加密过程，解密密钥可以通过勒索蠕虫作者的RSA私钥进行解密获得，而启动扇区级别的文件加密过程使用了随机密码进行，启动扇区级别的文件加密无法解密。</p>\n<h2 class="line" data-line="574">参考</h2>\n<p class="line" data-line="576"><a href="http://dengqi.blog.51cto.com/5685776/1351300">http://dengqi.blog.51cto.com/5685776/1351300</a></p>\n<p class="line" data-line="578"><a href="https://github.com/alexwebr/salsa20/blob/master/salsa20.c">https://github.com/alexwebr/salsa20/blob/master/salsa20.c</a></p>\n<p class="line" data-line="580"><a href="http://blog.csdn.net/enjoy5512/article/details/50966009">http://blog.csdn.net/enjoy5512/article/details/50966009</a></p>\n<p class="line" data-line="582"><a href="http://bobao.360.cn/learning/detail/4039.html">http://bobao.360.cn/learning/detail/4039.html</a></p>\n'}},serverRendered:!0}</script><script defer src="/_nuxt/manifest.38f62477280dcc27df9e.js"></script><script defer src="/_nuxt/vendor.bundle.45eca4dc7fa9e1bc4361.js"></script><script defer src="/_nuxt/nuxt.bundle.8e9d53f64bed77ebfe81.js"></script>